<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="CoalYa, Notes" />










<meta property="og:type" content="website">
<meta property="og:title" content="CoalYa&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CoalYa&#39;s Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoalYa&#39;s Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>CoalYa's Notes</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-110561175-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoalYa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">有态度很难，就做点记录吧。。。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/《深入理解ES6》之字符串和正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/《深入理解ES6》之字符串和正则表达式/" itemprop="url">《深入理解ES6》之字符串和正则表达式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T02:47:35-08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>18年的第一篇，回头看了看去年写的总结以及目标，完成了一小半，今年要更加努力才行。17年总体来说差强人意，代码写的依旧烂，当然也没留下太多遗憾。加入了新的公司，结识了一些简简单单的人。昨晚老爸问，有女朋友了吗？为什么没有？哎呀，刀刀暴击，不给活路。顿时思绪万千，额……失眠了。或许还没有成为理想中的自己吧，又或许其他。有些人，想着想着就远了，有些梦，做着做着就醒了。定几个小目标吧，1. 写好代码。毕竟这是立身之本。2. 学英语。努力赚钱，出国看看，语言还是很重要的。3. 学吉他。几年没弹过了，不忘初心嘛。4. 健身。报个健身房，撕裂吧腹肌胸肌肱二头肌。5. 考个驾照？</p>
</blockquote>
<p>ES6之前，JavaScript字符串是基于16位字符编码(UTF-16)进行构建。每16位序列是一个编码单元，代表一个字符。<code>length</code>、<code>charAt()</code>等字符串属性和方法都是基于这种编码单元构造的。</p>
<h3 id="UTF-16码位"><a href="#UTF-16码位" class="headerlink" title="UTF-16码位"></a>UTF-16码位</h3><p>Unicode为每一个字符提供了唯一的标识符，又称为码位，它是从0开始的数值。而表示字符的这些数值或者码位，称之为字符编码。</p>
<p>在UTF-16中，前2^16个码位均以16位的编码单元表示，这个范围称作<strong>基本多文种平面</strong>（BMP）。超出这个范围的码位则要归属于某个辅助平面，因为用16位已经无法表示。为此，UTF-16引入了<em>代理对</em>，规定用两个16位编码单元表示一个码位。</p>
<p>所以，字符串有两种，一种是由一个编码单元16位表示的BMP字符，另一种是有两个编码单元32位表示的<strong>辅助平面字符</strong></p>
<p>在ES5中，所有字符串的操作都是基于16位编码单元的BMP字符，如果直接用于32位编码单元的辅助平面字符，得到的结果可能与预期不符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>; <span class="comment">//不是‘吉’</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);      <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));  <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>))     <span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>))        <span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>))     <span class="comment">//55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>))     <span class="comment">//57271</span></div></pre></td></tr></table></figure></p>
<p><em>𠮷</em>是辅助平面字符，ES5中的字符串操作方法将其视为两个16位字符。</p>
<ul>
<li><code>text</code>的长度是1，但<code>length</code>属性值为2</li>
<li><code>text</code>被判定为两个字符，因此匹配单一字符的正则失效</li>
<li>前后两个16位编码都不表示任何可打印字符，所以<code>charAt()</code>方法不会返回合法的字符串</li>
<li><code>charCodeAt()</code>方法同样不能正确识别字符，他会返回每个16位编码单元对应的数值</li>
</ul>
<h3 id="ES6新增的字符串操作方法"><a href="#ES6新增的字符串操作方法" class="headerlink" title="ES6新增的字符串操作方法"></a>ES6新增的字符串操作方法</h3><p>ES6新增的字符串方法，完全支持UTF-16（辅助平面字符）</p>
<h4 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h4><p>该方法接受<em>编码单元</em>（非字符位置）的位置做为参数，返回字符串中给定位置对应的码位，即一个整数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">//55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">//57271</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">//97</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">//134071</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">//57271</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">//97</span></div></pre></td></tr></table></figure>
<p>对于BMP字符集中的字符，<code>codePointAt</code>和<code>charCodeAt</code>方法返回的值是相同的。<code>text</code>中第一个字符属于辅助平面字符，包含2个编码单元，<code>length</code>值为3。<code>charCodeAt</code>返回的只是位置0处的第一个编码单元，<code>charPointAt</code>返回的是完整的码位，即使这个码位包含2个编码单元。</p>
<p>检测字符占用的编码单元的数量，可以用<code>charPointAt</code>方法，返回值大于十六进制的上界值FFFF，则一定有两个编码单元来表示。（因为不足以表示所有字符，所以才用辅助平面字符来表示）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>)&gt; <span class="number">0xFFFF</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">'𠮷'</span>));  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">'a'</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h4 id="String-fromCodePoint-方法"><a href="#String-fromCodePoint-方法" class="headerlink" title="String.fromCodePoint()方法"></a>String.fromCodePoint()方法</h4><p><code>String.fromCodePoint()</code>接收一个码位，返回一个字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">//𠮷</span></div></pre></td></tr></table></figure></p>
<h4 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h4><p>Unicode中，对不同字符进行排序或比较操作，可能它们是等效的。有两种方式可以定义这种关系</p>
<ul>
<li>规范的等效，两个序列的码位一致</li>
<li>兼容性，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以被互相交换使用。</li>
</ul>
<p>比如Ǒ（\u01D1），O（\u004F）和ˇ（\u030C）组合，可以互相使用，但从严格意义上来讲，它们不是等效。ES6为字符串提供了一个<code>normalize</code>方法，它可以提供Unicode的标准化形式，该方法接收一个可选字符串参数。</p>
<ul>
<li>以标准等价方式分解，然后以标准等价方式重组（’NFC’），默认选项</li>
<li>以标准等价方式分解（NFD）</li>
<li>以兼容等价方式分解（’NFKC’）</li>
<li>以兼容等价方式分解，然后易标准等价方式重组（’NFKD’）<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u01D1'</span> === <span class="string">'\u004F\u030C'</span>);   <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize());   <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>在对比字符串之前，一定要先把它们标准化为同一格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> normalized = values.map(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> text.normalize()</div><div class="line">&#125;)</div><div class="line">normalized.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(a &lt; b)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a === b)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>将<code>values</code>数组中的所有字符都转换成同一种标准格式，因此该数组可以被正确排序</p>
<blockquote>
<p><code>sort</code>方法中的函数，返回值小于0，a在b前面。大于0，a在b后面。等于0，a，b相对位置不变。上面是升序</p>
</blockquote>
<h4 id="字符串中的子串识别"><a href="#字符串中的子串识别" class="headerlink" title="字符串中的子串识别"></a>字符串中的子串识别</h4><ul>
<li><code>includes()</code>，字符串中检测到指定文本返回<code>true</code>，否则<code>false</code></li>
<li><code>startsWith()</code>，字符串起始部分检测到指定文本返回<code>true</code>，否则<code>false</code></li>
<li><code>endsWith()</code>，字符串结束部分检测到指定文本返回<code>true</code>，否则<code>false</code><br>以上方法，都接受两个参数，第一个参数指定要搜索的文本，第二个参数可选，指定开始搜索的位置的索引值。如果指定第二个参数，<code>includes</code>和<code>startWith</code>方法会从这个索引值的位置开始匹配。<code>endsWith</code>方法则从字符串长度减去这个索引值的位置开始匹配。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> msg = <span class="string">'hello world!'</span></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'hello'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'!'</span>));     <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>));     <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'o'</span>, <span class="number">4</span>));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'o'</span>,<span class="number">8</span>))     <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>,<span class="number">8</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>重复字符串方法，接受一个<code>number</code>型参数，表示重复次数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>.repeat(<span class="number">2</span>));     <span class="comment">//'hellohello'</span></div></pre></td></tr></table></figure></p>
<h3 id="正则表达式变更"><a href="#正则表达式变更" class="headerlink" title="正则表达式变更"></a>正则表达式变更</h3><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>正则表达式默认将字符串中的每一个字符按照16位编码单元处理，为了解决这个问题，ES6新增u修饰符。当一个正则表达式添加了u修饰符时，它就从编码单元操作模式切换为字符模式。这样正则表达式就不会把辅助平面字符（代理对）为两个字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">'𠮷'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);   <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>可以利用u修饰符，检测字符串的码位<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</div><div class="line">    <span class="keyword">return</span> result? result.length: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">'abc'</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">'𠮷bc'</span>));   <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>检测u修饰符支持<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpU</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.'</span>, <span class="string">'u'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数使用了RegExp构造函数并传入一个修饰符u作为参数，老式浏览器支持这个语法，如果不支持u修饰符会抛出错误。这样可以避免发生语法错误。</p>
<h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><p>y修饰符的正则表达式称为粘滞正则表达式，他会影响正则表达式搜索过程中的<code>sticky</code>属性，当它在字符串中开始字符匹配时，会通知从正则表达式的<code>lastIndex</code>属性开始进行。如果指定位置未能成功匹配，则停止继续匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">'hello1 hello2 hello3'</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);     <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">//'hello1 '</span></div><div class="line"></div><div class="line">pattern.lastIndex = <span class="number">1</span>;</div><div class="line">globalPattern.lastIndex = <span class="number">1</span>;</div><div class="line">stickyPattern.lastIndex = <span class="number">1</span>;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);     <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">//'hello2 '</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">//抛出错误</span></div></pre></td></tr></table></figure></p>
<p>当<code>lastIndex</code>属性改成1时，此时正则表达式从字符串的第二个字符开始匹配。没有修饰符的表达式自动忽略，所以第二个表达式向后匹配到了’hello2 ‘，使用了y修饰符的粘滞正则表达式，由于从第二个字符开始匹配不到相应的字符串，就此终止。所以<code>stickyResult</code>为<code>null</code></p>
<ul>
<li>只有调用<code>exec()</code>和<code>test()</code>这些正则表达式对象的方法时才会涉及<code>lastIndex</code>属性，调用字符串方法如<code>match()</code>不会触发粘滞行为。</li>
<li>对于粘滞正则表达式，如果使用<code>^</code>匹配字符串开端，只会从字符串的起始位置或者多行模式的首行进行匹配。如果此时<code>lastIndex</code>值不为0，则永远不会匹配到结果</li>
</ul>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">资料1</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">资料2</a></p>
</blockquote>
<h4 id="正则表达式复制"><a href="#正则表达式复制" class="headerlink" title="正则表达式复制"></a>正则表达式复制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/ab/i</span>,</div><div class="line">    reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg1,<span class="string">'g'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reg2.toString());   <span class="comment">//  /ab/g</span></div></pre></td></tr></table></figure>
<p>在ES5环境中，<code>RegExp</code>构造函数，第一个参数为正则表达式时不可以使用第二个参数，ES6中修改了这个行为</p>
<h4 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h4><p><code>flags</code>属性用来获取正则表达式的修饰符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/ab/i</span>;</div><div class="line"><span class="built_in">console</span>.log(reg2.flags);    <span class="comment">//i</span></div></pre></td></tr></table></figure></p>
<h3 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h3><p>ES6模版字面量语法支持创建领域专用语言(DSL)，它比ES5及早起版本中的解决方案更家安全。</p>
<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;</div></pre></td></tr></table></figure>
<p>模版字面量用反撇号（`）表示，如果在字符串中使用反撇号，需要用反斜杆（\）进行转义</p>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>在ES5中，可以利用一个语法bug，在一个新行的最前方添加反斜杆（\）可以承接上一行代码，来创造多行字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'Multiline \</span></div><div class="line"><span class="string">string'</span></div><div class="line"><span class="keyword">var</span> message2 = <span class="string">'Multiline \n\</span></div><div class="line"><span class="string">string'</span></div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">//Multiline string</span></div><div class="line"><span class="built_in">console</span>.log(message2);  <span class="comment">//Multiline </span></div><div class="line">                        <span class="comment">//string</span></div></pre></td></tr></table></figure></p>
<p>反斜杆在此处代表行的延续，而非真正代表新的一行，如果想要输入新的一行，需要手动加入换行符。</p>
<p>ES6之前版本中，通常通过数组活着字符串拼接的方式创建多行字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = [<span class="string">'Multiline'</span>,<span class="string">'string'</span>].join(<span class="string">'\n'</span>);</div><div class="line"><span class="keyword">var</span> message2 = <span class="string">'Multiline \n'</span> + <span class="string">'string'</span></div></pre></td></tr></table></figure></p>
<p>在ES6中的模版字面量，只需在代码中直接换行即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">`Multiline</span></div><div class="line"><span class="string">string`</span></div><div class="line"><span class="built_in">console</span>.log(message);   <span class="comment">//Multiline </span></div><div class="line">                        <span class="comment">//string</span></div></pre></td></tr></table></figure></p>
<p>在反撇号中的所有空白符都输入字符串中的一部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">`Multiline</span></div><div class="line"><span class="string">    string`</span>         <span class="comment">//string前面有4个空格</span></div><div class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<p>第二行之前的所有空白符都是字符串本身的一部分</p>
<h4 id="字符串占位符"><a href="#字符串占位符" class="headerlink" title="字符串占位符"></a>字符串占位符</h4><p>占位符由一个美元符和大括号<code>${}</code>组成，中间可以包含任意的<code>JavaScript</code>表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = <span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"><span class="built_in">console</span>.log(message);    <span class="comment">//10 items cost $2.50.</span></div></pre></td></tr></table></figure></p>
<p>第一个美元符会原样输出，因为后面没有紧跟一个左括号</p>
<p>模版字面量本身也是<code>JavaScript</code>表达式，所以可以在一个模版中嵌入另一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'Nicholas'</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;</span></span></div><div class="line"><span class="string"><span class="subst">        <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span></span></span></div><div class="line"><span class="string"><span class="subst">    &#125;</span>.`</span>;</div><div class="line"><span class="built_in">console</span>.log(message);   <span class="comment">//Hello, my name is Nicholas.</span></div></pre></td></tr></table></figure></p>
<h3 id="模版标签"><a href="#模版标签" class="headerlink" title="模版标签"></a>模版标签</h3><p>在模版字面量第一个反撇号（`）前方标注的字符串（函数），就是标签。模版标签可以执行模版字面量上的转换，并返回最终的字符串值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = tag<span class="string">`hello world`</span></div></pre></td></tr></table></figure></p>
<p>如示，应用于模版字面量的模版标签是<code>tag</code></p>
<h4 id="定义标签"><a href="#定义标签" class="headerlink" title="定义标签"></a>定义标签</h4><p>标签是一个函数，调用时，第一个参数是一个数组，包含<code>JavaScript</code>解释过后的字面量字符串（模板字符串中那些没有变量替换的部分），之后的所有参数都是每一个占位符的解释值。</p>
<p>标签函数通常使用不定参数特征来定义占位符来简化处理过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = tag<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>)</span>&#123;</div><div class="line">    <span class="comment">// console.log(literals);   [ '', ' items cost $', '.' ]</span></div><div class="line">    <span class="comment">// console.log(substitutions); [ 10, '2.50' ]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例中，<code>tag</code>函数，作为一个模版字面量标签，会接受3个参数。<code>literals</code>是一个数组，包含一下元素</p>
<ul>
<li>第一个占位符前的空字符串（’’）</li>
<li>第一，二个占位符之间的字符串（’ items cost $’）</li>
<li>第二个占位符后的字符串（’.’）</li>
</ul>
<p>第二个参数是变量<code>count</code>的解释值，传参为10，最后一个是<code>count * price).toFixed(2)</code>的解释值，传参为’2.50’</p>
<p><code>literals</code>里第一个元素是空字符串，确保<code>literals[0]</code>是字符串始端，<code>substitutions</code>的数量始终比<code>literals</code>少一个，意味着<code>substitutions.length === literals.length-1</code>表达式始终为<code>true</code></p>
<p>模版标签可以到字符转义被转换成等价字符前的原生字符串，如<code>String.raw()</code>标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message1 = <span class="string">`Multiline\nstring`</span>,</div><div class="line">    message2 = <span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">//Multiline</span></div><div class="line">                        <span class="comment">//string</span></div><div class="line"><span class="built_in">console</span>.log(message2);  <span class="comment">//'Multiline\\nstring'</span></div></pre></td></tr></table></figure></p>
<p>变量<code>message1</code>中的<code>\n</code>解释为一个新行，变量<code>message2</code>获取的是<code>\n</code>的原生形式<code>\\n</code></p>
<p>原生字符串信息同样也传入标签模版，标签函数第一个参数，它有一个额外的属性<code>raw</code>，是一个包含每一个字面量的原生等价信息的数组。如<code>literals[0]</code>对应的原生字符串为<code>literals.raw[0]</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/16/《深入理解ES6》之块级作用域绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/16/《深入理解ES6》之块级作用域绑定/" itemprop="url">《深入理解ES6》之块级作用域绑定</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-16T18:16:01-08:00">
                2017-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="var声明及变量提升（Hoisting）机制"><a href="#var声明及变量提升（Hoisting）机制" class="headerlink" title="var声明及变量提升（Hoisting）机制"></a>var声明及变量提升（Hoisting）机制</h3><p>在函数作用域或全局作用域钟通过关键字<code>var</code>声明的变量，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升（Hoisting）机制<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        <span class="keyword">var</span> value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//此处可以可访问变量value，其值为undefined</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//此处可以可访问变量value，其值为undefined    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在预编译阶段，JavaScript引擎会将上面的<code>getValue</code>函数修改成下面这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量<code>value</code>的声明提升到函数顶部，初始化操作依然保留在原处执行，这就意味着在<code>else</code>语句中也可以访问到该变量，<br>且由于此时变量尚未初始化，所以其值为<code>undefined</code></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块级声明用于声明在指定块的作用域之外无法访问的变量，块级作用域存在于：</p>
<ul>
<li>函数内部</li>
<li>块中（{}内部）</li>
</ul>
<h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h4><p><code>let</code>声明的用法与<code>var</code>相同，用<code>let</code>声明的变量作用域限制在当前代码块中。由于<code>let</code>声明不会被提升，所以通常<br>将<code>let</code>声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        <span class="keyword">let</span> value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//变量value，此处不存在</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//变量value，此处不存在</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量<code>value</code>该用<code>let</code>声明后，不再提升至函数顶部，<code>if</code>语句执行完后，<code>value</code>立刻被销毁。如果<code>condition</code>为<br><code>false</code>，就永远不会声明并初始化<code>value</code></p>
<h4 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h4><p>如果作用域中已经存在某个标识符，此时再使用<code>let</code>关键字声明它就会抛出错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">//抛出错误</span></div><div class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</div></pre></td></tr></table></figure></p>
<p>变量<code>count</code>被声明了两次，所以在<code>let</code>声明处会抛出错误。但如果当前作用域内嵌另一个作用域，便可以在内嵌作用域<br>中用<code>let</code>声明同名变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"><span class="keyword">if</span>(condition) &#123;</div><div class="line">    <span class="comment">//不会抛出错误</span></div><div class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>关键字<code>const</code>用来声明一个常量，其值一旦设定后就不可更改。所以每个通过<code>const</code>声明的常量必须进行初始化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">//语法错误：常量未初始化</span></div><div class="line"><span class="keyword">const</span> name;</div></pre></td></tr></table></figure></p>
<h4 id="const与let"><a href="#const与let" class="headerlink" title="const与let"></a>const与let</h4><p><code>const</code>与<code>let</code>声明的都是块级标识符，所以也只在当前代码块内有效，也不会被提升至作用域顶部，在同一作用域中<br>也不能重复声明</p>
<h4 id="用const声明对象"><a href="#用const声明对象" class="headerlink" title="用const声明对象"></a>用const声明对象</h4><p><code>const</code>声明的变量不得改变值，对于引用类型数据，变量指向的内存地址，保存的是一个指针。<code>const</code>只能保证这个指针<br>是固定的，指针指向的数据结构是可变的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = &#123;</div><div class="line">    name: <span class="string">'Nico'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//可以修改对象属性的值</span></div><div class="line">Nico.name = <span class="string">'Greg'</span>;</div><div class="line"></div><div class="line"><span class="comment">//抛出语法错误</span></div><div class="line">person = &#123;</div><div class="line">    name: <span class="string">'Greg'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="暂时死区（Temporal-Dead-Zone）"><a href="#暂时死区（Temporal-Dead-Zone）" class="headerlink" title="暂时死区（Temporal Dead Zone）"></a>暂时死区（Temporal Dead Zone）</h4><p><code>let</code>和<code>const</code>声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使相对安全的<code>typeof</code>操作符<br>也会触发引用错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(condition) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">//引用错误</span></div><div class="line">    <span class="keyword">let</span> value = <span class="string">'blue'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>console.log(typeof value)</code>语句会抛出错误，因此用<code>let</code>定义并初始化变量<code>value</code>的语句不会执行，<br>此时<code>value</code>位于临时死区或TDZ中。</p>
<p>JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（<code>var</code>声明），要么将声明放到TDZ中（<code>let</code>和<code>const</code>）。<br>访问TDZ中的变量会出发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。</p>
<h3 id="循环中的块作用域绑定"><a href="#循环中的块作用域绑定" class="headerlink" title="循环中的块作用域绑定"></a>循环中的块作用域绑定</h3><h4 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h4><p><code>var</code>声明在循环中创建函数变得异常困难，因为变量到了循环之外也能访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//输出10次数字10</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是因为循环里的每次迭代同时共享着变量<code>i</code>，循环内部创建的函数全都保留了对相同变量的引用。循环结束时变量<br><code>i</code>的值为10，所以每次调用<code>console.log(i)</code>都会输出数字10</p>
<p>为了解决这个问题，可以使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(value)</div><div class="line">            &#125;</div><div class="line">        &#125;(i)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//0,1,...,9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在循环内部，IIFE表达式为接受的每一个变量<code>i</code>都创建了一个副本并存储为变量<code>value</code>。这个变量的值就是相应迭代创建<br>的函数所使用的值，因此调用每个函数都会像0到9循环一样得到期望的值。</p>
<h4 id="循环中的let声明"><a href="#循环中的let声明" class="headerlink" title="循环中的let声明"></a>循环中的let声明</h4><p>用<code>let</code>来声明上述示例，那么每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//0,1,...,9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于<code>for-in</code>循环和<code>for-of</code>循环，表现的行为和<code>for</code>循环保持一致。</p>
<h4 id="循环中的const声明"><a href="#循环中的const声明" class="headerlink" title="循环中的const声明"></a>循环中的const声明</h4><p>对于普通的<code>for</code>循环，可以在初始化变量时使用<code>const</code>，但是更改这个变量的值就会抛出错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>for-in</code>或<code>for-of</code>循环中使用<code>const</code>时的行为与使用<code>let</code>一致<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    obj = &#123;</div><div class="line">        a: <span class="literal">true</span>,</div><div class="line">        b: <span class="literal">false</span>,</div><div class="line">        c: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</div><div class="line">    func()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h3><p><code>let</code>和<code>const</code>与<code>var</code>的另外一个区别是它们在全局作用域的行为。当<code>var</code>被用于全局作用域时，它会创建一个新的全局<br>变量作为全局对象的属性。这意味着可能无意中覆盖了一个已经存在的全局变量。</p>
<p>而在全局作用域使用<code>let</code>或<code>const</code>，不会覆盖全局变量，只能遮蔽它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//浏览器中</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>,<span class="built_in">window</span>.RegExp);  <span class="comment">//'hello' 'hello'</span></div><div class="line"></div><div class="line"><span class="comment">//浏览器中</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>,<span class="built_in">window</span>.RegExp); <span class="comment">// 'hello' function RegExt()&#123; [native code] &#125;</span></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Context/" itemprop="url">Context</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T05:00:47-08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>React.js中，某个组件往自己的<code>context</code>里面放了某些状态，这个组件之下的所有子组件都可以直接访问这个状态，而不需要通过中间组件的传递。一个组件的<code>context</code>只有子组件能够访问，它的父组件是不能访问的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    themeColor: PropTypes.string,</div><div class="line">    num: PropTypes.number</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      themeColor: <span class="string">'red'</span>,</div><div class="line">      num: <span class="string">'helloworld'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      themeColor: <span class="keyword">this</span>.state.themeColor,</div><div class="line">      num: <span class="number">123</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;Head /&gt;</div><div class="line">        &lt;Main /&gt;</div><div class="line">        &lt;Footer /&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p><code>getChildContext</code>方法是用来设置<code>context</code>，返回的对象就是<code>context</code>，所有的子组件都是可以访问到这个对象。<code>childContextTypes</code>是用来验证<code>getChildContext</code>返回的对象<strong>必须要写</strong>。因为<code>context</code>是一个危险的特性，React.js团队想把危险的东西搞得复杂一点，提高使用门槛。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">        <span class="comment">// num: PropTypes.number,</span></div><div class="line">        themeColor: PropTypes.string</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="keyword">this</span>.context.themeColor&#125;&#125;&gt;这是底部了&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>子组件想要获取<code>context</code>里面的内容，就必须写<code>contextTypes</code>来声明和验证你需要获取的状态的类型，它也是<strong>必写的</strong>，否则无法获取<code>context</code>里面的状态。</p>
<p>一个组件中定义了<code>contextTypes</code>，那么在以下生命周期中，将会收到额外的参数，即 <code>context</code>对象</p>
<ul>
<li><code>constructor(props, context)</code></li>
<li><code>componentWillReceiveProps(nextProps, nextContext)</code></li>
<li><code>shouldComponentUpdate(nextProps, nextState, nextContext)</code></li>
<li><code>componentWillUpdate(nextProps, nextState, nextContext)</code></li>
<li><code>componentDidUpdate(nextProps, nextState, nextContext)</code></li>
</ul>
<h4 id="安全更新Context"><a href="#安全更新Context" class="headerlink" title="安全更新Context"></a>安全更新Context</h4><p>当<code>state</code>或者<code>props</code>更新时<code>getChildContext</code>方法会被调用，为了更新<code>context</code>，使用<code>this.setState</code>来更新本地<code>state</code>，这将会生成一个新的<code>context</code>，所有子组件都会接收到更新。</p>
<p>但如果有一个中间的父组件的<code>shouldComponentUpdate</code>返回了<code>false</code>（或者<code>PureComponent</code>组件），那么他的子组件<code>context</code>就不会被更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">        themeColor: PropTypes.string</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="keyword">this</span>.context.themeColor&#125;&#125;&gt;</div><div class="line">                这是标题</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class Main extends Component &#123;</span></div><div class="line"><span class="regexp">    shouldComponentUpdate() &#123;</span></div><div class="line"><span class="regexp">        return false;</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">        return(</span></div><div class="line"><span class="regexp">            &lt;div&gt;</span></div><div class="line"><span class="regexp">                &lt;Title /</span>&gt;</div><div class="line">                &lt;h3&gt;主体部分&lt;<span class="regexp">/h3&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了解决这个问题，可以通过基于<code>context</code>依赖注入进行变更。在适当的地方，建立一个依赖注入系统，然后向下传递需要管理的状态并订阅它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Theme</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(color) &#123;</div><div class="line">    <span class="keyword">this</span>.color = color</div><div class="line">    <span class="keyword">this</span>.subscriptions = []</div><div class="line">  &#125;</div><div class="line">  setColor(color) &#123;</div><div class="line">    <span class="keyword">this</span>.color = color</div><div class="line">    <span class="keyword">this</span>.subscriptions.forEach(<span class="function"><span class="params">f</span> =&gt;</span> f())</div><div class="line">  &#125;</div><div class="line">  subscribe(f) &#123;</div><div class="line">    <span class="keyword">this</span>.subscriptions.push(f)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeProvider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props)</div><div class="line">    <span class="keyword">this</span>.themeColor = <span class="keyword">new</span> Theme(<span class="keyword">this</span>.props.color)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    themeColor: PropTypes.object</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillReceiveProps(nextProps)&#123;</div><div class="line">    <span class="keyword">this</span>.themeColor.setColor(nextProps.color)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getChildContext()&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      themeColor: <span class="keyword">this</span>.themeColor</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class App extends Component &#123;</span></div><div class="line"><span class="regexp">  constructor() &#123;</span></div><div class="line"><span class="regexp">    super()</span></div><div class="line"><span class="regexp">    this.makeBlue = this.makeBlue.bind(this);</span></div><div class="line"><span class="regexp">    this.state = &#123;</span></div><div class="line"><span class="regexp">      color: 'red',</span></div><div class="line"><span class="regexp">      num: 'helloworld'</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  makeBlue() &#123;</span></div><div class="line"><span class="regexp">    this.setState(&#123;</span></div><div class="line"><span class="regexp">      color: 'blue'</span></div><div class="line"><span class="regexp">    &#125;)</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">  render() &#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">      &lt;ThemeProvider color=&#123; this.state.color &#125;&gt;</span></div><div class="line"><span class="regexp">        &lt;button onClick=&#123;this.makeBlue&#125;&gt;makeBule&lt;/</span>button&gt;</div><div class="line">        &lt;Head /&gt;</div><div class="line">        &lt;Main /&gt;</div><div class="line">        &lt;Footer /&gt;</div><div class="line">      &lt;<span class="regexp">/ThemeProvider&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Main</span></div><div class="line"><span class="regexp">class Title extends Component &#123;</span></div><div class="line"><span class="regexp">    static contextTypes = &#123;</span></div><div class="line"><span class="regexp">        themeColor: PropTypes.object</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">    </span></div><div class="line"><span class="regexp">    componentDidMount() &#123;</span></div><div class="line"><span class="regexp">        this.context.themeColor.subscribe( () =&gt; this.forceUpdate() )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">        return (</span></div><div class="line"><span class="regexp">            &lt;div style=&#123;&#123;color: this.context.themeColor.color&#125;&#125;&gt;</span></div><div class="line"><span class="regexp">                这是标题</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>调用<code>forceUpdate()</code>将会导致组件的<code>render()</code>方法被调用，并忽略<code>shouldComponentUpdate()</code>。这将会触发每一个子组件的生命周期方法，涵盖，每个子组件的<code>shouldComponentUpdate()</code>方法。</p>
</blockquote>
<p>我们创建了一个<code>Theme</code> 对象来保存状态，<code>Theme</code>对象同时也是一个事件发射器，这可以让像<code>Title</code>一样的组件来订阅未来的变化，<code>Theme</code>对象通过<code>ThemeProvider</code>在组件树中传递。只有刚开始的时候传递了<code>context</code>，后面的更新都通过<code>Theme</code>自己来传播，并没有重新创建一个<code>context</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/05/Canvas入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/05/Canvas入门/" itemprop="url">Canvas入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T02:44:34-08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Canvas/" itemprop="url" rel="index">
                    <span itemprop="name">Canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Canvas基础知识"><a href="#Canvas基础知识" class="headerlink" title="Canvas基础知识"></a>Canvas基础知识</h2><p><code>canvas</code>是HTML中的一个元素，使用<code>JavaScript</code>来绘制图形。可以添加一些HTML属性，也可以通过<code>style</code>设置一些样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</div><div class="line">        你的浏览器不支持canvas</div><div class="line">&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<p>默认大小为300*150，如果浏览器不支持，就会显示标签内的文本。</p>
<h3 id="获取上下文"><a href="#获取上下文" class="headerlink" title="获取上下文"></a>获取上下文</h3><p>绘制图形，先要获取到<code>canvas</code>的上下文对象<code>getContext()</code>。也可以通过该方法检测浏览器是否支持<code>canvas</code>,<code>getContext()</code>只有一个参数，用来指定上下文环境，比如<code>2D</code>，<code>webgl</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function canvasSupport(e)&#123;</div><div class="line">    return !!e.getContext</div><div class="line">&#125;</div><div class="line">function canvasApp()&#123;</div><div class="line">    var canvas = document.getElementById(&apos;canvas&apos;);</div><div class="line">    if(!canvasSupport(canvas))&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    var ctx = canvas.getContext(&apos;2d&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>在Canvas中的<code>2D</code>环境中的坐标系统和Web的坐标系统是一样的（笛卡尔坐标），坐标原点<code>(0,0)</code>在<code>canvas</code>的左上角，向右为<code>x</code>轴正向，向下为<code>y</code>轴正向</p>
<p><code>3D</code>环境中的坐标系统，多了一个<code>z</code>轴，<code>z</code>轴正向从屏幕穿出</p>
<h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><p>Canvas只支持一种原生的图形绘制：矩形。所有其他的图形绘制都需要先生成路径，然后描边或填充。Canvas提供了三种绘制矩形的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!--绘制一个填充的矩形--&gt;</div><div class="line">fillRect(x,y,width,height)</div><div class="line"></div><div class="line">&lt;!--绘制一个描边的矩形--&gt;</div><div class="line">strokeRect(x,y,width,height)</div><div class="line"></div><div class="line">&lt;!--清除一个矩形区域，让清除部分完全透明--&gt;</div><div class="line">fillRect(x,y,width,height)</div></pre></td></tr></table></figure>
<h4 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h4><ul>
<li>创建路径的起点</li>
<li>画出路径</li>
<li>封闭路径</li>
<li>描边或者填充路径区域来渲染图形<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!--新建一条路径（重新开始一条路径,它将重置内存中现有的路径）--&gt;</div><div class="line">beginPath()</div><div class="line"></div><div class="line">&lt;!--闭合路径 如果路径是打开的，使用当前点和起始点的连线闭合。--&gt;</div><div class="line">closePath()</div><div class="line"></div><div class="line">&lt;!--描边--&gt;</div><div class="line">stroke()</div><div class="line"></div><div class="line">&lt;!--填充，所有没闭合的形状都会自动闭合--&gt;</div><div class="line">fill()</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><p><code>moveTo(x,y)</code>移动到某一点，通常用来设置路径的起点<br><code>lineTo(x,y)</code>绘制一条从当前到指定位置的直线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function canvasSupport(e)&#123;</div><div class="line">    return !!e.getContext</div><div class="line">&#125;</div><div class="line">(function canvasApp()&#123;</div><div class="line">    var canvas = document.getElementById(&apos;canvas&apos;);</div><div class="line">    if(!canvasSupport(canvas))&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    var ctx = canvas.getContext(&apos;2d&apos;)</div><div class="line"></div><div class="line">    &lt;!--填充三角形--&gt;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.moveTo(50,50);</div><div class="line">    ctx.lineTo(110,50);</div><div class="line">    ctx.lineTo(110,130);</div><div class="line">    ctx.fill();</div><div class="line"></div><div class="line">    &lt;!--描边三角形--&gt;</div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.moveTo(200,50);</div><div class="line">    ctx.lineTo(140,50);</div><div class="line">    ctx.lineTo(140,130);</div><div class="line">    ctx.closePath();</div><div class="line">    ctx.stroke();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<blockquote>
<p>路径使用填充时，路径自动闭合，使用描边则不会，如果没有使用<code>closePath()</code>，则只会绘制出两条线段</p>
<p><code>lineWidth</code>设置线宽</p>
</blockquote>
<h4 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h4><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code>，以(x,y)为圆心，以radius为半径的圆弧（圆），startAngle表示开始弧度，endAngle表示结束弧度，anticlockwise为布尔值表示方向（默认顺时针，true为逆时针）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!--四分之一圆弧--&gt;</div><div class="line">ctx.beginPath();</div><div class="line">ctx.arc(150,150,50,0,Math.PI/2,false);</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">&lt;!--四分之三圆弧--&gt;</div><div class="line">ctx.beginPath();</div><div class="line">ctx.arc(150,300,50,0,Math.PI/2,true);</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure></p>
<p><code>arcTo(x1,y1,x2,y2,radius)</code>以（x1,y1）和（x2,y2）为控制点，以radius为半径画一段圆弧。</p>
<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p><code>quadraticCurveTo(cp1x,cp1y,x,y)</code>，二次贝塞尔曲线，(cp1x,cp1y)为控制点，（x,y）为结束点</p>
<p><code>bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</code>，三次贝塞尔曲线，（cp1x,cp1y），（cp2x,cp2y）为控制点，（x,y）为结束点</p>
<h3 id="样式和颜色"><a href="#样式和颜色" class="headerlink" title="样式和颜色"></a>样式和颜色</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p><code>fillStyle</code>,<code>strokeStyle</code>设置图形的颜色，<code>fillStyle</code>设置填充颜色，<code>strokeStyle</code>设置描边颜色。属性值可以是一个表示CSS颜色值的字符串，也可以是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient" target="_blank" rel="external">CanvasGradient</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasPattern" target="_blank" rel="external">CanvasPattern</a>对象</p>
<h4 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h4><p>可以通过设置<code>globalAlpha</code>属性或者使用一个包含透明度颜色作为描边或填充的样式来实现包含透明度的图形，该属性值范围氏0.0～1.0，默认为1.0不透明</p>
<h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!--ctx为画布上下文对象  --&gt;</div><div class="line"></div><div class="line">&lt;!--线宽  --&gt;</div><div class="line">ctx.lineWidth=value;</div><div class="line"></div><div class="line">&lt;!--线型末端类型  --&gt;</div><div class="line">ctx.lineCap=type;</div><div class="line"></div><div class="line">&lt;!--两条线接合处类型  --&gt;</div><div class="line">ctx.lineJoin=type;</div><div class="line"></div><div class="line">&lt;!--限制当两条线相交时交接处最大长度  --&gt;</div><div class="line">ctx.miterLimit=value;</div><div class="line"></div><div class="line">&lt;!--获取当前虚线样式  --&gt;</div><div class="line">ctx.getLineDash();</div><div class="line"></div><div class="line">&lt;!--虚线样式  --&gt;</div><div class="line">ctx.setLineDash(segments);</div><div class="line"></div><div class="line">&lt;!--虚线样式起始偏移量  --&gt;</div><div class="line">ctx.lineDashOffset=value;</div></pre></td></tr></table></figure>
<p><code>lineCap</code>线段端点有三个值，<code>butt</code>，<code>round</code>，<code>square</code>，其中<code>butt</code>是默认值</p>
<ul>
<li><code>butt</code>线段末端以方形结束</li>
<li><code>round</code>线段末端以圆形结束，增加了以线段宽度为直径的半圆区域</li>
<li><code>square</code>线段末端以方形结束，增加了宽度和线段相同，高度是线段厚度的一半的矩形区域</li>
</ul>
<p><code>lineJoin</code>线段连接点有三个值，<code>miter</code>，<code>round</code>，<code>bevel</code>，其中<code>miter</code>是默认值</p>
<ul>
<li><code>miter</code>通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。这个设置可以通过miterLimit属性看到效果。</li>
<li><code>round</code>通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。圆角的半径是线段的宽度。</li>
<li><code>bevel</code>在相连部分的末端填充一个额外的以三角形为底的区域，每个部分都有各自独立的矩形拐角。</li>
</ul>
<p><code>miterLimit</code>设定外延交点与连接点的最大距离，斜线长度与二分之一线宽的比值，如果大于设定的<code>miterLimit</code>，就会以<code>bevel</code>方式处理连接处</p>
<p><code>setLineDash</code>接受一个参数<code>segments</code>，这个参数是一个数组，一组描绘交替绘制线段和间距长度的数字</p>
<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>新建一个<code>canvasGradient</code>对象，并赋值给图形的<code>fillStyle</code>或<code>strokeStyle</code>属性，来实现线性渐变和径向渐变的填充或者描边</p>
<p>线性渐变使用<code>createLinearGradient(x1, y1, x2, y2)</code>创建<code>canvasGradient</code>对象，（x1,y1），(x2,y2)表示渐变的起点和终点</p>
<p>径向渐变使用<code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code>创建<code>canvasGradient</code>对象，以3个参数为一组，圆心坐标，半径，表示两个圆。</p>
<p>创建完<code>canvasGradient</code>对象，调用<code>addColorStop(position,color)</code>方法定义渐变的颜色，<code>position</code>表示位置，值范围在0.0～1.0之间，<code>color</code>制定渐变中的颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var lingrad = ctx.createLinearGradient(50,50,50,250);</div><div class="line">lingrad.addColorStop(0, &apos;#00ABEB&apos;);</div><div class="line">lingrad.addColorStop(0.5, &apos;#fff&apos;);</div><div class="line">lingrad.addColorStop(0.5, &apos;#26C000&apos;);</div><div class="line">lingrad.addColorStop(1, &apos;#fff&apos;);</div><div class="line">ctx.fillStyle = lingrad;</div><div class="line">ctx.fillRect(50,50,200,200);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var radgrad = ctx.createRadialGradient(45, 45, 10, 52, 50, 30);</div><div class="line">radgrad.addColorStop(0, &apos;#A7D30C&apos;);</div><div class="line">radgrad.addColorStop(0.9, &apos;#019F62&apos;);</div><div class="line">radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);</div><div class="line">ctx.fillStyle = radgrad;</div><div class="line">ctx.fillRect(0, 0, 150, 150);</div></pre></td></tr></table></figure>
<h4 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h4><p>通过<code>createPattern(image,type)</code>创建一个<code>CanvasPattern</code>对象，参数<code>image</code>可以是一个Image对象的引用，或者另一个canvas对象，<br>type参数的值有<code>repeat</code>，<code>repeat-x</code>，<code>repeat-y</code>，<code>no-repeat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var img = new Image();</div><div class="line">img.src = &apos;image/wallpaper.jpg&apos;;</div><div class="line">img.onload = function()&#123;</div><div class="line">    var ptrn = ctx.createPattern(img,&apos;no-repeat&apos;);</div><div class="line">    ctx.fillStyle = ptrn;</div><div class="line">    ctx.fillRect(50,50,300,300);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><ul>
<li><code>shadowOffsetX = float</code>和<code>shadowOffsetY = float</code>用来设定阴影在X和Y轴的延伸距离</li>
<li><code>shadowBlur = float</code>阴影模糊值</li>
<li><code>shadowColor = color</code>阴影颜色，默认黑色</li>
</ul>
<blockquote>
<p>赋值给fillStyle前，先要确保图片已经加载完毕，不然效果可能不对</p>
</blockquote>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>canvas提供了两个方法绘制文本，<code>fillText(text,x,y,[,maxWidth])</code>和<code>strokeText(text,x,y,[,maxWidth])</code>，分别表示填充文本和<br>描边文本</p>
<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><ul>
<li><p><code>font=value</code><br>绘制文本的样式，和<code>CSS font</code>属性相同的语法，默认字体为<code>10px sans-serif</code></p>
</li>
<li><p><code>textAlign=value</code><br>文本对齐方式，可选值包括：<code>left</code>，<code>right</code>，<code>center</code>，<code>start</code>，<code>end</code>默认为<code>start</code></p>
</li>
</ul>
<blockquote>
<p><code>end</code>，<code>start</code>表示界限结束地方对齐，文本界限开始地方对齐，当<code>direction=ltr</code>，则<code>left</code>和<code>start</code>效果相同<br><code>center</code>表示基于<code>x</code>位置居中，相对于<code>x</code>左右均分</p>
</blockquote>
<ul>
<li><p><code>textBaseline=value</code><br>基线对齐方式，可选的值包括：<code>top</code>， <code>hanging</code>， <code>middle</code>， <code>alphabetic</code>， <code>ideographic</code>， <code>bottom</code>。默认值是 <code>alphabetic</code>。<br><img src="http://www.whatwg.org/specs/web-apps/current-work/images/baselines.png" alt=""></p>
</li>
<li><p><code>direction=value</code><br>文本方向，可能的值包括：<code>ltr</code>， <code>rtl</code>， <code>inherit</code>。默认值是 <code>inherit</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ctx.font=&apos;48px serif&apos;;</div><div class="line">ctx.textAlign = &apos;center&apos;;</div><div class="line">ctx.strokeText(&apos;hello world&apos;,200,200);</div></pre></td></tr></table></figure>
<h4 id="文本测量"><a href="#文本测量" class="headerlink" title="文本测量"></a>文本测量</h4><p>当需要更多文本细节时，可以通过<code>measureText()</code>方法获得，该方法返回<code>TextMetrics</code>对象，包含一个<code>width</code>属性</p>
<h3 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h3><ul>
<li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片</li>
<li>使用drawImage()函数将图片绘制到画布上</li>
</ul>
<h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h4><p>通过<code>drawImage()</code>方法渲染到canvas里，<code>drawImage</code>方法有三种不同形态</p>
<ul>
<li><code>drawImage(image,x,y)</code>，其中<code>image</code>时image，vedio或者canvas对象，<code>x</code>，<code>y</code>表示其在canvas里的起始坐标</li>
<li><code>drawImage(image,x,y,width,height)</code>，其中<code>width</code>和<code>height</code>用来控制其在canvas中的大小</li>
<li><code>drwaImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)</code>，第一个参数和其他的是相同的，其他8个参数<br>，前4个表示对图片的裁剪，后4个表示裁剪后的图片在canvas里显示的位置和大小</li>
</ul>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h4><p><code>save()</code>和<code>restore()</code>用来保存和恢复canvas状态，canvas的状态就是当前画面应用的所有样式和变形的一个快照</p>
<p><code>save()</code>方法被调用后，当前的状态就被推送到栈中保存，绘画状态包括</p>
<ul>
<li>当前变形</li>
<li>样式，strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation</li>
<li>裁切路径</li>
</ul>
<p>可以多次调用<code>save()</code>方法，每次调用<code>restore()</code>，上一个保存的状态就从栈中弹出</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p><code>translate(x,y)</code>，移动canvas的坐标原点，<code>x</code>，<code>y</code>分别表示x，y方向的偏移量</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><code>rotate()</code>以canvas坐标原点为中心旋转，该方法接受一个参数：旋转角度，它是以顺时针方向，以弧度<br>为单位的值</p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p><code>scale(x,y)</code>，<code>x</code>，<code>y</code>表示缩放的比例，不能为负数，1.0表示保持原样</p>
<h4 id="变形-1"><a href="#变形-1" class="headerlink" title="变形"></a>变形</h4><p><code>transform(m11,m12,m21,m22,dx,dy)</code>，这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，<br>m11：水平方向的缩放，m12：水平方向的偏移，m21：竖直方向的偏移，m22：竖直方向的缩放，dx：水平方向的移动，dy：竖直方向的移动</p>
<p><code>setTransform(m11,m12,m21,m22,dx,dy)</code>这个方法会将当前的变形矩阵重置为单位矩阵</p>
<p><code>resetTransform()</code>，重置当前变形为单位矩阵，等同<code>ctx.setTransform(1, 0, 0, 1, 0, 0);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var sin = Math.sin(Math.PI/6);</div><div class="line">var cos = Math.cos(Math.PI/6);</div><div class="line">ctx.translate(200, 200);</div><div class="line">var c = 0;</div><div class="line">for (var i=0; i &lt;= 12; i++) &#123;</div><div class="line">    c = Math.floor(255 / 12 * i);</div><div class="line">    ctx.fillStyle = &quot;rgb(&quot; + c + &quot;,&quot; + c + &quot;,&quot; + c + &quot;)&quot;;</div><div class="line">    ctx.fillRect(0, 0, 100, 10);</div><div class="line">    ctx.transform(cos, sin, -sin, cos, 0, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ctx.setTransform(-1, 0, 0, 1, 100, 100);</div><div class="line">ctx.fillStyle = &quot;rgba(255, 128, 255, 0.5)&quot;;</div><div class="line">ctx.fillRect(0, 50, 100, 100);</div></pre></td></tr></table></figure>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h4><p><code>globalCompositeOperation=type</code>设置图形与图形之间的层叠方式，<a href="https://codepen.io/airen/pen/EWexYx" target="_blank" rel="external">效果</a></p>
<h4 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h4><p><code>clip()</code> 方法来创建一个新的裁切路径。默认情况下，canvas 有一个与它自身一样大的裁切路径</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="CoalYa" />
            
              <p class="site-author-name" itemprop="name">CoalYa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoalYa</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
