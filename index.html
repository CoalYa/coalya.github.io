<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
      
    
    
      
    
  <script src="https://lib.baomitu.com/pace/1.0.2/pace.min.js"></script>
  <link href="https://lib.baomitu.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="https://lib.baomitu.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="CoalYa, Notes" />










<meta property="og:type" content="website">
<meta property="og:title" content="CoalYa&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CoalYa&#39;s Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoalYa&#39;s Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>CoalYa's Notes</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-110561175-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoalYa's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">有态度很难，就做点记录吧。。。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/09/Iterator-and-Generator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/Iterator-and-Generator/" itemprop="url">迭代器（Iterator）和生成器（Generator）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T07:37:47+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用循环语句迭代数据时，需要初始化一个变量来记录每一次迭代在数据集合中的位置，使用迭代器对象返回迭代过程中集合每一个元素，可以极大简化数据操作。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种特殊的对象，他有一个<code>next()</code>方法，每次调用都返回一个结果对象。结果对象有两个属性，一个是<code>value</code>，表示下一个将要返回的值，一个是<code>done</code>，他是一个布尔类型的值，当没有更多可返回的数据时返回<code>true·</code>。迭代器还会保存一个内部指针，用来指向当前集合中的位置，每调用一次<code>next()</code>方法，都会返回下一个可用的值。</p>
<p>如果在最后一个值返回后再调用<code>next()</code>方法，返回对象中属性<code>done</code>的值为<code>true</code>，属性<code>value</code>的值为包含迭代器最终返回的值，这个值不是数据集的一部分，如果没有相关数据则返回<code>undefined</code>。</p>
<p>下面用ES5来模拟一个迭代器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> done = (i &gt;= items.length);</div><div class="line">            <span class="keyword">var</span> value = !done ? items[i++]: <span class="literal">undefined</span>;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                done: done,</div><div class="line">                value: value</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]);</div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; done: false, value: 2 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; done: false, value: 4 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; done: false, value: 6 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; done: true, value: undefined &#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是一种返回迭代器的函数，通过<code>function</code>关键字后的星号（<code>*</code>）来表示，星号可以紧挨着<code>function</code>关键字，也可以在中间添加一个空格。函数中用到关键词<code>yield</code>，可以通过它来指定调用迭代器的<code>next()</code>方法时的返回值及返回顺序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//生成器的调用和其他函数一样，最终返回的是创建好的迭代器</span></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: 1, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>
<p>每当执行完一条<code>yield</code>语句后，函数就会自动停止执行。每次调用<code>next()</code>方法，函数会继续执行并执行下一条<code>yield</code>语句。上面代码中，执行完<code>yield 1</code>语句之后，函数便不在执行其他语句，直到再次调用迭代器的<code>next()</code>方法才会继续执行<code>yield 2</code>语句。使用<code>yield</code>关键字可以返回任何值或表达式，所以可通过生成器函数批量地给迭代器添加元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;items.length; i++)&#123;</div><div class="line">        <span class="keyword">yield</span> items[i]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>]);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>yield</code>关键字只可在生成器内部使用，在其他地方使用会导致程序抛出语法错误，即使在生成器内部的函数里使用也是如此。比如上例生成器内部改为<code>items.forEach(i =&gt; {yield i});</code>会抛出错误。</p>
</blockquote>
<ul>
<li>生成器表达式<br>可以通过函数表达式来创建生成器，在<code>function</code>关键字和小括号中间添加一个星号（<code>*</code>）即可<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++)&#123;</div><div class="line">        <span class="keyword">yield</span> items[i]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>不能用箭头函数来创建生成器</p>
</blockquote>
<ul>
<li>生成器对象的方法<br>由于生成器本身是就是函数，可以将它们添加到对象中。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o = &#123;</div><div class="line">    createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++)&#123;</div><div class="line">            <span class="keyword">yield</span> items[i]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//ES6函数方法的简写方式</span></div><div class="line">    <span class="comment">// *createIterator(items)&#123;</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="可迭代对象和for-of循环"><a href="#可迭代对象和for-of循环" class="headerlink" title="可迭代对象和for...of循环"></a>可迭代对象和<code>for...of</code>循环</h3><p>可迭代对象具有<code>Symbol.iterator</code>属性，该属性是一个生成器函数。<code>Symbol.iterator</code>通过指定的函数可以返回一个作用于附属对象的迭代器。ES6中，所有集合对象（数组、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="external">TypedArray</a>、<code>Set</code>集合及<code>Map</code>集合）和字符串都是可迭代对象，这些对象中都有默认的迭代器。</p>
<blockquote>
<p>生成器默认会为<code>Symbol.iterator</code>属性赋值，通过生成器创建的迭代器都是可迭代对象。</p>
</blockquote>
<p><code>for...of</code>循环需要用到可迭代对象的功能，循环每执行一次都会调用可迭代对象的<code>next()</code>方法，并将迭代器返回结果对象的<code>value</code>属性存储在一个变量中，循环遇到返回结果对象<code>done</code>属性的值为<code>undefined</code>时终止。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> arr)&#123;</div><div class="line">   <span class="built_in">console</span>.log(num); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>for...of</code>循环通过调用数组<code>arr</code>的<code>Symbol.iterator</code>方法来获取迭代器，这一过程是在JavaScript引擎中完成的。随后迭代器的<code>next()</code>方法别多次调用，从其返回对象的<code>value</code>属性读取值并存储在变量<code>num</code>中，当结果对象<code>done</code>属性值为<code>true</code>时循环退出，所以<code>num</code>不会被赋值<code>undefined</code>。</p>
<blockquote>
<p><code>for...of</code>语句用于不可迭代对象、<code>null</code>或<code>undefined</code>将会导致程序抛出错误。</p>
</blockquote>
<ul>
<li>访问默认迭代器</li>
</ul>
<p>可以通过<code>Symbol.iterator</code>来访问对象默认的迭代器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: 4, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: 6, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">//&#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure></p>
<p>具有<code>Symbol.iterator</code>属性的对象都有默认的迭代器，可以用它来检测对象是否为可迭代对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>创建可迭代对象</li>
</ul>
<p>默认情况下，开发者定义的对象是不可迭代对象，可以给<code>Symbol.iterator</code>属性添加一个生成器，这样就可以将其变成可迭代对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    items: [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items)&#123;</div><div class="line">            <span class="keyword">yield</span> item</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//2，4，6</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>未完待续…</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/30/Set-and-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/30/Set-and-Map/" itemprop="url">Set集合和Map集合</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T22:46:22+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Set集合是一种无重复元素的列表。Map集合内含多组键值对，集合中每个元素分别存放着可访问的键名和它对应的值。</p>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>调用<code>new Set()</code>创建<code>Set</code>集合，调用<code>add</code>方法向集合中添加元素，访问<code>size</code>属性可以获取集合中目前的元素数量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">'5'</span>);</div><div class="line">set.add(key1);</div><div class="line">set.add(key2);</div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//4</span></div></pre></td></tr></table></figure></p>
<p>在<code>Set</code>集合中，不会对所存值进行强制的类型转换，数字5和字符串”5”是作为两个独立元素存在。由于<code>key1</code>和<code>key2</code>不会转换成字符串，因而它们再<code>Set</code>集合中是两个独立的元素。</p>
<p>如果多次调用<code>add</code>方法，并传入相同的值作为参数，那么后续的调用实际上会被忽略。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">'5'</span>);</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>可以用数组来初始化<code>Set</code>集合，<code>Set</code>构造函数会过滤掉重复的值以保证集合中的元素各自唯一。可以通过<code>has</code>方法检测<code>Set</code>集合中是否存在某个值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>]);</div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">9</span>));    <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Set</code>构造函数可以接受所有可迭代对象作为参数，构造函数通过迭代器从参数中取值。</p>
</blockquote>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>调用<code>delete()</code>方法可以移除<code>Set</code>集合中的某一个元素，调用<code>clear()</code>方法会移除集合中所有元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">'5'</span>);</div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">//true</span></div><div class="line">set.delete(<span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//1</span></div><div class="line"></div><div class="line">set.clear();</div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="string">'5'</span>));  <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<h4 id="Set集合的forEach方法"><a href="#Set集合的forEach方法" class="headerlink" title="Set集合的forEach方法"></a>Set集合的forEach方法</h4><p><code>forEach</code>方法的回调函数接受3个参数</p>
<ul>
<li><code>Set</code>集合中元素的值</li>
<li>与第一个参数一样的值</li>
<li>被遍历<code>Set</code>集合本身</li>
</ul>
<blockquote>
<p><code>Set</code>集合没有键名，第一二个参数相等，保证其他<code>forEach</code>方法的一致性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">7</span>]);</div><div class="line">set.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, ownerSet</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value,key);</div><div class="line">    <span class="built_in">console</span>.log(set === ownerSet);</div><div class="line">&#125;)</div><div class="line"><span class="comment">//4 4 true 7 7 true</span></div></pre></td></tr></table></figure>
<p><code>Set</code>集合中的<code>forEach</code>方法中，第二个参数也与数组的一样，传递到回调函数中来指代<code>this</code>值。</p>
<h4 id="将Set集合转换为数组"><a href="#将Set集合转换为数组" class="headerlink" title="将Set集合转换为数组"></a>将<code>Set</code>集合转换为数组</h4><p>使用展开运算符（<code>...</code>）可以将<code>Set</code>集合（可迭代对象）转换为数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>]),</div><div class="line">    arr = [...set];</div><div class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//[ 1, 2, 4, 3, 5, 7 ]</span></div></pre></td></tr></table></figure></p>
<h4 id="Weak-Set集合"><a href="#Weak-Set集合" class="headerlink" title="Weak Set集合"></a>Weak Set集合</h4><p>将对象存储在<code>Set</code>的实例与存储在变量中完全一样，只要<code>Set</code>实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</div><div class="line">    key = &#123;&#125;;</div><div class="line"></div><div class="line">set.add(key);</div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">//移除原始引用</span></div><div class="line">key = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(set.size);  <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">//重新取回原始引用</span></div><div class="line">key = [...set][<span class="number">0</span>]</div></pre></td></tr></table></figure></p>
<p>示例中将变量<code>key</code>设置为<code>null</code>，清除了对初始对象的引用，但<code>Set</code>集合却保留了这个引用。有时候可能需要当其他所有引用不再存在时，<code>Set</code>集合中的这些引用随之消失。</p>
<p>ES6引入了另外一个类型，Weak Set集合（弱引用<code>Set</code>集合）。Weak Set集合只会存储对象的弱引用，不可以存储原始值，集合中弱引用是对象的唯一的引用，则会被回收并释放相应内存。</p>
<ul>
<li>创建<br>用<code>WeakSet</code>构造函数可以创建Weak Set集合，也向构造函数可以传入一个可迭代对象来创建Weak Set集合。集合支持3个方法<code>add</code>、<code>has</code>和<code>delete</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(),</div><div class="line">    key = &#123;&#125;;</div><div class="line"></div><div class="line">set.add(key);</div><div class="line"><span class="built_in">console</span>.log(set.has(key));</div><div class="line"></div><div class="line"><span class="comment">//移除对象key的最后一个强引用，Weak Set中的引用也自动移除</span></div><div class="line">key = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;,</div><div class="line">    set1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([key1, key2]);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>WeakSet</code>构造函数中，不接受任何原始值，否则会抛出错误。</p>
<h4 id="两种Set类型的主要区别"><a href="#两种Set类型的主要区别" class="headerlink" title="两种Set类型的主要区别"></a>两种<code>Set</code>类型的主要区别</h4><ul>
<li>在<code>WeakSet</code>实例中，如果向<code>add</code>、<code>has</code>和<code>delete</code>这3个方法中传入非对象参数都会导致程序报错。</li>
<li><code>Weak Set</code>集合不可迭代，所以不能用于<code>for-of</code>循环。</li>
<li><code>Weak Set</code>不暴露任何迭代器（例如<code>keys</code>和<code>values</code>方法）所以无法通过程序本身来检测其中内容。</li>
<li><code>Weak Set</code>不支持<code>forEach</code>方法，不支持<code>size</code>属性。</li>
</ul>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><code>Map</code>类型是一种储存着键值对的有序列表，其中键名和对应的值支持所有数据类型。键名不会被强制转换成其他形式，其的等价判断通过<code>Object.is</code>方法实现。</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>调用<code>new Map()</code>创建<code>Map</code>集合，调用<code>set</code>方法并传入键名和对应值作为两个参数。调用<code>get</code>方法传入键名可以获取对应的值，如果传入的键名不存在则会返回<code>undefined</code>。也可以向<code>Map</code>构造函数传入数组来创建一个<code>Map</code>集合，数组中每一个元素都是一个子数组，子数组中包含一个键值对的键名与值两个元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">let</span> key = &#123;&#125;;</div><div class="line">map1.set(<span class="string">'title'</span>, <span class="string">'Understanding'</span>);</div><div class="line">map1.set(<span class="string">'year'</span>, <span class="number">2000</span>);</div><div class="line">map1.set(key, <span class="string">'lala'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map1.get(<span class="string">'title'</span>));  <span class="comment">//'Understanding'</span></div><div class="line"><span class="built_in">console</span>.log(map1.get(<span class="string">'year'</span>));   <span class="comment">//2000</span></div><div class="line"><span class="built_in">console</span>.log(map1.get(key));  <span class="comment">//'lala'</span></div><div class="line"><span class="built_in">console</span>.log(map1.get(<span class="string">'name'</span>));   <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'Nicholas'</span>], [<span class="string">'age'</span>, <span class="number">25</span>]]);</div><div class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'name'</span>));  <span class="comment">//'Nicholas'</span></div><div class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'age'</span>));   <span class="comment">//25</span></div></pre></td></tr></table></figure></p>
<h4 id="Map集合支持的方法"><a href="#Map集合支持的方法" class="headerlink" title="Map集合支持的方法"></a>Map集合支持的方法</h4><p><code>Map</code>和<code>Set</code>集合有3个通用的方法</p>
<ul>
<li><code>has</code>检测指定键名在<code>Map</code>集合中是否存在</li>
<li><code>delete</code>从<code>Map</code>集合中删除指定键名及其对应的值</li>
<li><code>clear</code>移除<code>Map</code>集合中的所有键值对</li>
</ul>
<p><code>Map</code>集合也支持<code>size</code>属性，代表当前集合中包含的键值对数量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</div><div class="line">map.set(<span class="string">'age'</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.size);  <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>));   <span class="comment">//true</span></div><div class="line"></div><div class="line">map.delete(<span class="string">'name'</span>);</div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'name'</span>));   <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(map.size);  <span class="comment">//1</span></div><div class="line"></div><div class="line">map.clear();</div><div class="line"><span class="built_in">console</span>.log(map.size);  <span class="comment">//0</span></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'age'</span>));    <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h4 id="Map集合的forEach方法"><a href="#Map集合的forEach方法" class="headerlink" title="Map集合的forEach方法"></a>Map集合的forEach方法</h4><p><code>Map</code>集合中<code>forEach</code>方法和<code>Set</code>集合的<code>forEach</code>方法类似，其回调函数接受3个参数</p>
<ul>
<li><code>Map</code>集合中元素的值</li>
<li>值对应的键名</li>
<li><code>Map</code>集合本身</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'name'</span>, <span class="string">'Nicholas'</span>], [<span class="string">'age'</span>, <span class="number">20</span>]]);</div><div class="line">map.forEach(<span class="function">(<span class="params">value, key, ownerMap</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>);</div><div class="line">    <span class="built_in">console</span>.log(ownerMap === map);</div><div class="line">&#125;)</div><div class="line"><span class="comment">//'name' 'Nicholas'</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//'age' 20</span></div><div class="line"><span class="comment">//true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>也可以指定<code>forEach</code>函数的第二个参数作为回调的<code>this</code>值</p>
</blockquote>
<h4 id="Weak-Map集合"><a href="#Weak-Map集合" class="headerlink" title="Weak Map集合"></a>Weak Map集合</h4><p><code>Weak Map</code>类型是一种存储键值对的无序列表，键名必须是非<code>null</code>类型对象，键名对应的值可以是任意类型。</p>
<p>和<code>Weak Set</code>集合类似，<code>Weak Map</code>是弱引用<code>Map</code>集合，用于存储对象的弱引用，集合中保存的是对象的弱引用，如果弱引用之外不存在其他的强引用，引擎垃圾回收机制会自动回收这个对象，同时也会移除<code>Weak Map</code>集合中的键值对。但只有集合中的键名遵从这个规则，键名对应的值如果是一个对象，则保存的是对象的强引用，不会触发垃圾回收机制。</p>
<ul>
<li><p>初始化<br>调用<code>WeakMap</code>构造函数创建一个<code>Weak Map</code>，通过<code>set</code>方法添加数据，通过<code>get</code>方法获取数据。也可以通过传入一个数组，数组内的元素为一个数组，该数组有两个元素构成，第一个是键名，传入的值必须是非<code>null</code>对象，第二个是键名对应的值，可以是任意值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</div><div class="line">    ele = <span class="built_in">document</span>.querySelector(<span class="string">'.ele'</span>);</div><div class="line"></div><div class="line">map1.set(ele, <span class="string">'original'</span>);</div><div class="line"><span class="keyword">let</span> value = map.get(ele);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(value); <span class="comment">//'original'</span></div><div class="line"></div><div class="line"><span class="comment">//移除ele元素</span></div><div class="line">ele.parentNode.removeChild(ele);</div><div class="line">ele = <span class="literal">null</span>; </div><div class="line"><span class="comment">// Weak Map 集合为空</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;,</div><div class="line">    map2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[key1, <span class="string">'hello'</span>], [key2, <span class="string">'world'</span>]]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map2.has(key1));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(map2.get(key1));    <span class="comment">//'hello'</span></div></pre></td></tr></table></figure>
</li>
<li><p>支持的方法<br><code>Weak Map</code>集合只支持两个可以操作键值对的方法：<code>has</code>和<code>delete</code>方法，<code>has</code>方法用于检测给定键在集合中是否存在，<code>delete</code>方法可以移除指定的键值对。和<code>Weak Set</code>一样，二者都不支持键名枚举，也不支持<code>clear</code>方法。</p>
</li>
<li><p>私有对象数据<br><code>Weak Map</code>集合一般用于储存DOM元素，还有一个实际的应用是存储对象实例的私有数据</p>
</li>
</ul>
<p>在ES5中，可以通过下面这种模式创建一个接近真正私有数据的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> privateData = &#123;&#125;,</div><div class="line">        privateId = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'_id'</span>, &#123;</div><div class="line">            value: privateId++</div><div class="line">        &#125;)</div><div class="line">        privateData[<span class="keyword">this</span>._id] = &#123;</div><div class="line">            name: name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> privateData[<span class="keyword">this</span>._id].name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Person</div><div class="line">&#125;())</div></pre></td></tr></table></figure></p>
<p><code>Person</code>又一个立即调用函数表达式生成，包括两个私有变量：<code>privateData</code>和<code>privateId</code>，<code>privateData</code>对象保存的是每个实例的私有信息，<code>privateId</code>则为每个实例生成一个独立的ID。当调用<code>Person</code>构造函数时，属性<code>_id</code>的值会加1，这个属性不可枚举，不可写，不可配置。</p>
<p><code>privateData</code>对象保存了所有实例对应的名称，调用<code>getName</code>函数，即可通过<code>this._id</code>获取当前示例的ID，并以此从<code>privateData</code>对象提取实例名称。</p>
<p>这种方法最大的问题是，如果不主动管理，由于无法获知对象实例何时被销毁，因此<code>privateData</code>中的数据永远都不会消失。使用<code>Weak Map</code>集合就可以解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        privateData.set(<span class="keyword">this</span>, &#123;<span class="attr">name</span>: name&#125;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Person</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>由于<code>Person</code>对象实例可以直接作为集合的键使用，无需维护一套ID体系来跟踪数据。这样只要对象实例被销毁，相关信息也会被销毁，保证了信息的私有性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/Symbol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/Symbol/" itemprop="url">Symbol</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T07:21:14+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Symbol和Symbol属性"><a href="#Symbol和Symbol属性" class="headerlink" title="Symbol和Symbol属性"></a>Symbol和Symbol属性</h2><p><code>Symbol</code>是ES6引入的第6种原始类型数据。ES6之前，属性名都是字符串类型，<code>Symbol</code>可以为属性添加非字符串名称。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>所有原始值，除了<code>Symbol</code>以外都有各自的字面量形式。通过全局的<code>Symbol</code>函数来创建一个<code>Symbol</code>，<code>Symbol</code>函数接受一个可选参数，用来描述即将创建的<code>Symbol</code>，这段描述不可用于属性访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>);</div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line">person[firstName] = <span class="string">'Nicholas'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'first name'</span> <span class="keyword">in</span> person);    <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">//'Nicholas'</span></div><div class="line"><span class="built_in">console</span>.log(firstName);     <span class="comment">//'Symbol(first name)'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> firstName); <span class="comment">//'symbol'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>不能通过<code>new</code>调用<code>Symbol</code>函数，这样会导致程序错误。<br>ES6扩展了<code>typeof</code>操作符，支持检测<code>Symbol</code>类型。<br><code>Symbol</code>的描述被存储在内部的<code>[[Description]]</code>属性中，只有调用<code>Symbol</code>的<code>toString</code>方法时才可以读取这个属性。执行<code>console.log</code>时，隐式调用了<code>firstName</code>的<code>toString</code>方法。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>所有使用可计算属性名的地方，都可以使用<code>Symbol</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>);</div><div class="line"><span class="comment">//使用一个可计算对象字面量属性</span></div><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    [firstName]: <span class="string">'Nicholas'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);</div><div class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">'last name'</span>);</div><div class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</div><div class="line">    [lastName]: &#123;</div><div class="line">        value: <span class="string">'Zakas'</span>,</div><div class="line">        writable: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="Symbol共享体系"><a href="#Symbol共享体系" class="headerlink" title="Symbol共享体系"></a>Symbol共享体系</h3><p>有时可能需要在不同的代码中共享同一个<code>Symbol</code>，使用<code>Symbol.for()</code>方法，创建一个共享的<code>Symbol</code>。该方法接受一个参数，也就是即将创建的<code>Symbol</code>的字符串标识符，这个参数也作为<code>Symbol</code>的描述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>);</div><div class="line"><span class="keyword">let</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line">obj[uid] = <span class="string">'123'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(uid === uid2);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(obj[uid2]);     <span class="comment">//123</span></div><div class="line"><span class="built_in">console</span>.log(uid2);          <span class="comment">//'Symbol(uid)'</span></div></pre></td></tr></table></figure></p>
<p><code>Symbol.for()</code>方法首先在全局<code>Symbol</code>注册表中搜索键为<code>uid</code>的<code>Symbol</code>是否存在，如果存在，返回已有的<code>Symbol</code>。否则，创建一个新的<code>Symbol</code>，并使用这个键在<code>Symbol</code>全局注册表中注册，随即返回新的<code>Symbol</code>。</p>
<p>可以使用<code>Symbol.keyFor()</code>方法在<code>Symbol</code>全局注册表中检索与<code>Symbol</code>有关的键。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid));    <span class="comment">//'uid'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2));   <span class="comment">//'uid'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">'uid'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3));   <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p><code>uid</code>和<code>uid2</code>都返回<code>&quot;uid&quot;</code>这个键，而在全局注册表中不存在<code>uid3</code>这个<code>Symbol</code>，也就不存在与之有关的键，所以返回<code>undefined</code>。</p>
<h3 id="Symbol与类型强制转换"><a href="#Symbol与类型强制转换" class="headerlink" title="Symbol与类型强制转换"></a>Symbol与类型强制转换</h3><p>JavaScript中，某些情况下，会发生自动转换类型行为。然而，其他类型没有与<code>Symbol</code>逻辑等价的值，尤其是不能将<code>Symbol</code>强制转换成字符串和布尔值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>),</div><div class="line">    desc = <span class="built_in">String</span>(uid);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(desc);</div><div class="line"></div><div class="line"><span class="keyword">let</span> desc2 = uid + <span class="string">''</span>;   <span class="comment">//TypeError: Cannot convert a Symbol value to a string</span></div><div class="line"><span class="keyword">let</span> sum = uid/<span class="number">1</span>;    <span class="comment">//TypeError: Cannot convert a Symbol value to a number</span></div></pre></td></tr></table></figure></p>
<p><code>String()</code>函数调用了<code>uid.toString</code>方法，返回字符串类型的<code>Symbol</code>描述里的内容。但是将<code>Symbol</code>强制转换成字符串或数字类型，会抛出错误。</p>
<h3 id="Symbol属性检索"><a href="#Symbol属性检索" class="headerlink" title="Symbol属性检索"></a>Symbol属性检索</h3><p><code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>方法可以检索对象中的属性名，前一个返回所有可枚举属性，后一个不考虑是否可枚举，一律返回。这两个方法都不支持<code>Symbol</code>属性。ES6中新增一个<code>Object.getOwnPropertySymbols()</code>方法检索对象中的<code>Symbol</code>属性，该方法返回一个包含所有<code>Symbol</code>自有属性（非继承）的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">'uid'</span>);</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    [uid]: <span class="number">123</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</div><div class="line"><span class="built_in">console</span>.log(symbols);   <span class="comment">//[ Symbol(uid) ]</span></div></pre></td></tr></table></figure></p>
<h3 id="通过well-known-Symbol暴露内部操作"><a href="#通过well-known-Symbol暴露内部操作" class="headerlink" title="通过well-known Symbol暴露内部操作"></a>通过well-known Symbol暴露内部操作</h3><p>ES6开放了以前JavaScript中常用的内部操作，并通过预定义一些well-known Symbol来表示。每一个这类<code>Symbol</code>都是<code>Symbol</code>对象的一个属性。这些well-known Symbol包括</p>
<ul>
<li><code>Symbol.hasInstance</code>一个在执行<code>instanceof</code>时调用的内部方法，用于检测对象的继承信息。</li>
<li><code>Symbol.isConcatSpreadable</code>一个布尔值，用于表示当传递一个集合作为<code>Array.prototype.concat()</code>方法的参数时，是否应该将集合内的元素归整到同一层级。</li>
<li><code>Symbol.iterator</code>一个返回迭代器方法</li>
<li><code>Symbol.match</code>、<code>Symbol.replace</code>、<code>Symbol.search</code>、<code>Symbol.split</code>分别在调用<code>String.prototype.match()</code>、<code>String.prototype.replace()</code>、<code>String.prototype.search()</code>、<code>String.prototype.split()</code>方法时调用的方法</li>
<li><code>Symbol.species</code>用于创建派生类的构造函数。</li>
<li><code>Symbol.toPrimitive</code>一个返回对象原始值的方法</li>
<li><code>Symbol.toStringTag</code>一个在调用<code>Object.prototype.toString()</code>方法时使用的字符串，用于创建对象描述。</li>
<li><code>Symbol.unscopables</code>一个定义了一些不可被<code>with</code>语句引用的对象属性名称的对象集合。</li>
</ul>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><p>每一个函数都有一个<code>Symbol.hasInstance</code>方法，用于确定对象是否是函数的实例。该方法在<code>Function.prototye</code>中定义，所有函数都继承了<code>instanceof</code>属性的默认行为。该方法不可写，不可配置并且不可枚举。</p>
<p><code>Symbol.hasInstance</code>方法只接受一个参数，即要检查的值。如果传入的值是函数的实例，则返回<code>true</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> myObject();</div><div class="line">obj <span class="keyword">instanceof</span> myObject;    <span class="comment">//true</span></div><div class="line">myObject[<span class="built_in">Symbol</span>.hasInstance](obj);  <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>本质上，ES6只是将<code>instanceof</code>操作符重新定义为此方法的简写语法。现在引入调用后，就可以随意改变<code>instanceof</code>的运行方式了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//给myObject定义一个Symbol.hasInstance用来屏蔽继承</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="built_in">Symbol</span>.hasInstance, &#123;</div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> myObject();</div><div class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> myObject);   <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><code>obj</code>是<code>myObject</code>的实例，因为给<code>myObject</code>改写<code>Symbol.hasInstance</code>，为其定义一个总是返回<code>false</code>的新函数。</p>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p><code>Symbol.isConcatSpreadable</code>属性是一个布尔值，如果该属性值为<code>true</code>，则表示对象有<code>length</code>属性和数字键，它的数值型属性值应该被独立添加到<code>concat()</code>调用结果中。它与其他well-known Symbol不同的是，这个<code>Symbol</code>属性默认情况下不会出现在标准对象中，它是一个可选属性，用于增强作用于特定对象类型的<code>concat()</code>方法的功能，有效简化其默认特性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">'hello'</span>,</div><div class="line">    <span class="number">1</span>: <span class="string">'world'</span>,</div><div class="line">    a: <span class="number">12</span>,</div><div class="line">    length: <span class="number">2</span>,</div><div class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> messages = [<span class="string">'Hi'</span>].concat(collection);</div><div class="line"><span class="built_in">console</span>.log(messages.length);   <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(messages);  <span class="comment">//[ 'Hi', 'hello', 'world' ]</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>也可以在派生数组子类中将<code>Symbol.isConcatSpreadable</code>设置为<code>false</code>，从而防止元素在调用<code>concat()</code>方法时被分解。</p>
</blockquote>
<h4 id="Symbol-match、Symbol-replace、Symbol-search、Symbol-split属性"><a href="#Symbol-match、Symbol-replace、Symbol-search、Symbol-split属性" class="headerlink" title="Symbol.match、Symbol.replace、Symbol.search、Symbol.split属性"></a>Symbol.match、Symbol.replace、Symbol.search、Symbol.split属性</h4><p>字符串方法<code>match</code>、<code>replace</code>、<code>search</code>、<code>split</code>可以接受正则表达式作为参数，在ES6之前，无法使用开发者自定义的对象来替代正则表达式进行字符串匹配。在ES6中，定义了与上述方法对应的<code>Symbol</code>，这4个<code>Symbol</code>属性表示对应字符串方法的第一个参数应该调用的正则表达式参数的方法，它们定义在<code>RegExp.prototype</code>中，是字符串方法应该使用的默认是想。</p>
<ul>
<li><code>Symbol.match</code>接受一个字符串类型的参数，如果匹配成功，返回匹配元素的数组，否则返回<code>null</code></li>
<li><code>Symbol.replace</code>接受一个字符串类型的参数和一个替换用的字符串，最终返回一个字符串</li>
<li><code>Symbol.search</code>接受一个字符串参数，如果匹配到内容，则返回数字类型的索引位置，否则返回-1</li>
<li><code>Symbol.split</code>接受一个字符串参数，根据匹配内容将字符串分解，并返回一个包含分解后片段的数组</li>
</ul>
<p>如果在对象中定义这些属性，即使不使用正则表达式和以正则表达式为参的方法也可以在对象中实现模式匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</div><div class="line">    [<span class="built_in">Symbol</span>.match]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span>? [value.substring(<span class="number">0</span>,<span class="number">10</span>)]: <span class="literal">null</span></div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.replace]: <span class="function"><span class="keyword">function</span>(<span class="params">value, replacement</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span>?  value: replacement + value.substring(<span class="number">10</span>)</div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span>? <span class="number">0</span>: <span class="number">-1</span></div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.split]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span>? [<span class="string">""</span>, <span class="string">""</span>]: [value]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> msg1 = <span class="string">'Hello world'</span>,</div><div class="line">    msg2 = <span class="string">'Hello John'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> match1 = msg1.match(hasLengthOf10),</div><div class="line">    match2 = msg2.match(hasLengthOf10),</div><div class="line">    replace1 = msg1.replace(hasLengthOf10, <span class="string">'hey'</span>),</div><div class="line">    replace2 = msg2.replace(hasLengthOf10, <span class="string">'hey'</span>),</div><div class="line">    search1 = msg1.search(hasLengthOf10),</div><div class="line">    search2 = msg2.search(hasLengthOf10),</div><div class="line">    split1 = msg1.split(hasLengthOf10),</div><div class="line">    split2 = msg2.split(hasLengthOf10);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(match1, match2);    <span class="comment">//null [ 'Hello John' ]</span></div><div class="line"><span class="built_in">console</span>.log(replace1, replace2);    <span class="comment">//'heyd' 'Hello John'</span></div><div class="line"><span class="built_in">console</span>.log(search1, search2);  <span class="comment">//-1 0</span></div><div class="line"><span class="built_in">console</span>.log(split1, split2);    <span class="comment">//[ 'Hello world' ] [ '', '' ]</span></div></pre></td></tr></table></figure></p>
<p>尽管<code>hasLengthOf10</code>不是正则表达式，但给它添加了相应的<code>Symbol</code>属性，所以传递给字符串方法，可以正常运行。</p>
<h4 id="Symbol-toPrimitive方法"><a href="#Symbol-toPrimitive方法" class="headerlink" title="Symbol.toPrimitive方法"></a>Symbol.toPrimitive方法</h4><p>再JavaScript引擎中，当执行特定操作时，会尝试将对象转换到相应的原始值。到底使用哪一个原始值以前是由内部操作决定的。在ES6中，通过<code>Symbol.toPrimitive</code>方法可以更改返回的原始值。</p>
<p><code>Symbol.toPrimitive</code>方法被定义在每一个标准类型的原型上，并且规定了当对象被转换为原始值应当执行的操作。当执行原始值转换时，总是会调用<code>Symbol.toPrimitive</code>方法并传入一个值做为参数，这个值在规范中被称作类型提示（<code>hint</code>）。该值有3个选择：<code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;default&quot;</code>，对应这些参数，<code>Symbol.toPrimitive</code>返回的分别是：数字、字符串、无类型偏好的值。</p>
<p>当<code>Symbol.toPrimitive</code>方法参数传入的为<code>&quot;number&quot;</code>，大多数标准对象，有以下特性。</p>
<ul>
<li>调用<code>valueOf</code>方法，如果结果是原始值，则返回</li>
<li>否则，调用<code>toString</code>方法，如果结果是原始值，则返回</li>
<li>如果无再可选值，则抛出错误</li>
</ul>
<p>当<code>Symbol.toPrimitive</code>方法参数传入的为<code>&quot;string&quot;</code>，大多数标准对象，有以下特性。</p>
<ul>
<li>调用<code>toString</code>方法，如果结果是原始值，则返回</li>
<li>否则，调用<code>valueOf</code>方法，如果结果是原始值，则返回</li>
<li>如果无再可选值，则抛出错误</li>
</ul>
<p>大多数情况下，标准对象会将默认模式按数字（<code>&quot;number&quot;</code>）模式处理（<code>Date</code>对象，默认模式是字符模式）。可以自定义<code>Symbol.toPrimitive</code>方法，覆盖这些默认的强制转换特性。</p>
<blockquote>
<p>默认模式只用于<code>==</code>、<code>+</code>运算以及<code>Date</code>构造函数传递一个参数时。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temperature</span>(<span class="params">degrees</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.degrees = degrees</div><div class="line">&#125;</div><div class="line">Temperature.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(hint)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'string'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">'\u00b0'</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'number'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees;</div><div class="line">        <span class="keyword">case</span> <span class="string">'default'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">' degress'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> freezing = <span class="keyword">new</span> Temperature(<span class="number">32</span>);</div><div class="line"><span class="built_in">console</span>.log(freezing + <span class="string">'!'</span>);    <span class="comment">//32 degress!</span></div><div class="line"><span class="built_in">console</span>.log(freezing / <span class="number">2</span>);  <span class="comment">//16</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(freezing));  <span class="comment">//32°</span></div></pre></td></tr></table></figure>
<p>这里在构造函数<code>Temperature.prototype</code>上定义了<code>Symbol.toPrimitive</code>屏蔽了继承的<code>Symbol.toPrimitive</code>方法。新的方法根据<code>hint</code>指定的模式返回不同的值（<code>hint</code>有JavaScript引擎传入）。</p>
<h4 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h4><p>ES6中，通过<code>Symbol.toStringTag</code>改变调用<code>Object.prototype.toString</code>时返回的身份标识。这个<code>Symbol</code>所代表的属性在每一个对象中都存在，其定义了调用对象的<code>Object.prototype.toString.call()</code>方法时返回的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'Person'</span>;</div><div class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>);</div><div class="line"><span class="built_in">console</span>.log(me.toString()); <span class="comment">//'[object Person]'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me));    <span class="comment">//'[object Person]'</span></div></pre></td></tr></table></figure></p>
<p><code>Person.prototype</code>继承了<code>Object.prototype.toString()</code>方法，所以调用<code>me.toString()</code>方法时也使用了<code>Symbol.toStringTag</code>的返回值。</p>
<h4 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h4><p><code>with</code>语句设计的初衷是免于编写重复代码，但由此会带来，代码可读性变差，执行性能差且容易导致程序出错。最终标准规定，严格模式下，不可以使用<code>with</code>语句。且这条限制同样影响到了类和模块，默认使用严格模式且没有任何退出的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</div><div class="line">    colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>],</div><div class="line">    color = <span class="string">'black'</span>;</div><div class="line"></div><div class="line"><span class="keyword">with</span>(colors)&#123;</div><div class="line">    push(color);</div><div class="line">    push(...values)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ES6环境中，<code>with</code>语句引用的<code>values</code>不是<code>with</code>语句外的变量<code>values</code>，而是数组本身的<code>values</code>方法，这样就脱离了代码原本的目标。（测试还是使用<code>with</code>语句外的变量，Node v10.0.0）。</p>
<p>ES6增加<code>Symbol.unscopables</code>，这个<code>Symbol</code>通常用于<code>Array.prototype</code>，已在<code>with</code>语句中标示出不创建绑定的属性名。<code>Symbol.unscopables</code>是以对象的形式出现，它的键是在<code>with</code>语句中要忽略的标识符，对应的值必须为<code>true</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables] = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</div><div class="line">    copyWithin: <span class="literal">true</span>,</div><div class="line">    entries: <span class="literal">true</span>,</div><div class="line">    fill: <span class="literal">true</span>,</div><div class="line">    find: <span class="literal">true</span>,</div><div class="line">    findIndex: <span class="literal">true</span>,</div><div class="line">    keys: <span class="literal">true</span>,</div><div class="line">    values: <span class="literal">true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这里在<code>Array.prototype</code>的<code>Symbol.unscopables</code>定义了ES6新的数组方法，这样在<code>with</code>语句中不再创建这些方法的绑定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/《深入理解ES6》之解构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/《深入理解ES6》之解构/" itemprop="url">《深入理解ES6》之解构</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T06:59:01+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>解构是一种打破数据结构，将其拆分为更小部分的过程。</p>
<p>ES5及早期版本，从对象和数组中获取特定数据并赋值给变量，实现可能如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> opts = &#123;</div><div class="line">    repeat: <span class="literal">true</span>,</div><div class="line">    save: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> repeat = opts.repeat,</div><div class="line">    save = opts.save;</div></pre></td></tr></table></figure></p>
<p>这样如果提取更多变量，则需要重复编写类似的代码来为变量赋值。解构简化了获取数据的过程。</p>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>对象解构的语法形式是在一个赋值操作左边放置一个对象字面量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</div><div class="line"><span class="built_in">console</span>.log(type);  <span class="comment">//'Identifier'</span></div><div class="line"><span class="built_in">console</span>.log(name);  <span class="comment">//'foo'</span></div></pre></td></tr></table></figure></p>
<p><code>node.type</code>的值赋值给变量<code>type</code>。</p>
<blockquote>
<p>使用<code>var</code>、<code>let</code>或<code>const</code>解构声明变量，必须要提供等号右侧的值。如<code>var { type, name }</code>，则会抛出错误。右侧的值为<code>null</code>和<code>undefined</code>也会报错，因为读取<code>null</code>和<code>undefined</code>的属性都会出发运行错误。</p>
</blockquote>
<ul>
<li>解构赋值<br>可以用在变量赋值时使用解构语法，如在定义变量后，修改他们的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        type: <span class="string">'Identifier'</span>,</div><div class="line">        name: <span class="string">'foo'</span></div><div class="line">    &#125;,</div><div class="line">    type = <span class="string">'Literal'</span>,</div><div class="line">    name = <span class="number">5</span>;</div><div class="line">(&#123; type, name &#125; = node);</div><div class="line"><span class="built_in">console</span>.log(type);  <span class="comment">//'Identifier'</span></div><div class="line"><span class="built_in">console</span>.log(name);  <span class="comment">//'foo'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>一定要用括号包裹结构赋值语句，JavaScript引擎将一对开放的大括号视为一个代码块，代码块不允许出现在赋值语句的左侧，添加小括号其转化为一个表达式。</p>
</blockquote>
<ul>
<li>默认值<br>使用解构赋值表达式时，如果指定的变量名称在对象中不存在，那么这个变量会被赋值为<code>undefined</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</div><div class="line"><span class="built_in">console</span>.log(value); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>当指定属性不存在的时候，可以定义一个默认值，和函数默认参数一样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; type, name, value=<span class="literal">true</span> &#125; = node;</div><div class="line"><span class="built_in">console</span>.log(value); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<ul>
<li>为非同名变量赋值<br>上面解构赋值使用的都是与对象属性同名的变量，如<code>node.type</code>的值赋值给了变量<code>type</code>，可以使用不同命名的变量。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</div><div class="line"><span class="built_in">console</span>.log(localType); <span class="comment">//'Identifier'</span></div><div class="line"><span class="built_in">console</span>.log(localName); <span class="comment">//'foo'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种语法与原来的对象字面量的语法相悖，这里是名称在冒号右边。使用其他变量名进行赋值时，也可以添加默认值，在变量名后添加等号和默认值即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName=<span class="string">'bar'</span> &#125; = node;</div></pre></td></tr></table></figure></p>
<ul>
<li>嵌套对象解构<br>解构嵌套对象与对象字面量类似，可以将更深层级对象拆解以获取想要的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span>,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: <span class="number">1</span>,</div><div class="line">            column: <span class="number">1</span></div><div class="line">        &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: <span class="number">1</span>,</div><div class="line">            column: <span class="number">4</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125; &#125; = node;</div><div class="line"><span class="built_in">console</span>.log(start); <span class="comment">//&#123; line: 1, column: 1 &#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>嵌套对象解构中，冒号前的标识符都代表在对象中的检索位置，右侧为被赋值的变量名。如果冒号后是花括号，则意味着获取的值在更深的层级中。同样也可以使用与对象属性名不同的变量名。</p>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>使用数组字面量且解构操作全部在数组内完成。通过值在数组中的位置进行选取，且可以将其存储在任意变量中。这个过程中，不影响数组本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="keyword">let</span> [firstColor, secondColor] = colors;</div><div class="line"><span class="built_in">console</span>.log(firstColor);    <span class="comment">//'red'</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);   <span class="comment">//'green'</span></div></pre></td></tr></table></figure></p>
<p>在解构模式中，也可以只提取制定数组中的值，使用逗号做为占位符，想要获取数组某个位置的值，指定变量名，其他用逗号占位即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="keyword">let</span> [,, thirdColor] = colors;</div><div class="line"><span class="built_in">console</span>.log(thirdColor);    <span class="comment">//'blue'</span></div></pre></td></tr></table></figure></p>
<ul>
<li>解构赋值<br>在变量赋值也是可以使用数组解构，但是不需要使用小括号。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>],</div><div class="line">    firstColor = <span class="string">'black'</span>,</div><div class="line">    secondColor = <span class="string">'purple'</span>;</div><div class="line"></div><div class="line">[firstColor, secondColor] = colors;</div><div class="line"><span class="built_in">console</span>.log(firstColor);    <span class="comment">//'red'</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);   <span class="comment">//'green'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>数组解构中，有个独特的用例：交换两个变量的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5中交换两个变量，需要引入第三个临时变量</span></div><div class="line"><span class="comment">// let a = 1,</span></div><div class="line"><span class="comment">//     b = 2,</span></div><div class="line"><span class="comment">//     tmp;</span></div><div class="line"><span class="comment">// tmp = a;</span></div><div class="line"><span class="comment">// a = b;</span></div><div class="line"><span class="comment">// b = tmp;</span></div><div class="line"></div><div class="line"><span class="comment">//ES6中</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</div><div class="line">    b = <span class="number">2</span>;</div><div class="line"></div><div class="line">[a, b] = [b, a];</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>赋值语句左侧事一个解构模式，右侧是一个为交换过程创建的临时数组字面量。代码执行过程，将临时数组解构，把<code>b</code>和<code>a</code>的值复制到左侧数组的前两个位置，最终变量交换了它们的值。</p>
<blockquote>
<p>同对象解构赋值一样，右侧表达式的值不能为<code>null</code>或<code>undefined</code></p>
</blockquote>
<ul>
<li><p>默认值<br>可以在数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的的值不存在或者其值为<code>undefined</code>时，使用默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>];</div><div class="line"><span class="keyword">let</span> [firstColor, secondColor=<span class="string">'blue'</span>] = colors;</div><div class="line"><span class="built_in">console</span>.log(firstColor);    <span class="comment">//'red'</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);   <span class="comment">//'blue'</span></div></pre></td></tr></table></figure>
</li>
<li><p>嵌套数组解构<br>嵌套数组解构和嵌套对象解构类似，在原有的解构模式中，插入另一个解构模式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, [<span class="string">'green'</span>, <span class="string">'lighitgreen'</span>], <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [firstColor, [secondColor]] = colors;</div><div class="line"><span class="built_in">console</span>.log(firstColor);    <span class="comment">//'red'</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);   <span class="comment">//'green'</span></div></pre></td></tr></table></figure>
</li>
<li><p>不定元素<br>在数组解构中，可以通过<code>...</code>语法将数组中的其余元素赋值给一个特定的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [firstColor,  ...restColors] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);    <span class="comment">//'red'</span></div><div class="line"><span class="built_in">console</span>.log(restColors);    <span class="comment">//[ 'green', 'blue' ]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>还可以通过不定元素的语法实现复制一个数组的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="comment">// var cloneColors = colors.concat();</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [...cloneColors] = colors;</div><div class="line"><span class="built_in">console</span>.log(cloneColors);   <span class="comment">//[ 'red', 'green', 'blue' ]</span></div></pre></td></tr></table></figure></p>
<h4 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h4><p>可以混合使用对象解构和数组解构来创建更多复杂的表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    type: <span class="string">'Identifier'</span>,</div><div class="line">    name: <span class="string">'foo'</span>,</div><div class="line">    loc: &#123;</div><div class="line">        start: &#123;</div><div class="line">            line: <span class="number">1</span>,</div><div class="line">            column: <span class="number">1</span></div><div class="line">        &#125;,</div><div class="line">        end: &#123;</div><div class="line">            line: <span class="number">1</span>,</div><div class="line">            column: <span class="number">4</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    range: [<span class="number">0</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; </div><div class="line">    loc: &#123; start &#125;,</div><div class="line">    range: [startIndex]</div><div class="line">&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(start.line);    <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(start.column);  <span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(startIndex);    <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<p>解构模式中的<code>loc</code>和<code>range</code>仅代表它们在<code>node</code>对象中所处的位置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/05/Git小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/Git小结/" itemprop="url">Git小结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T01:39:07+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h4><p>Git是最流行的分布式版本控制系统，SVN是集中式的版本控制系统。</p>
<p>集中式：版本集中存放在中央服务器，工作时，先从中央服务器取得最新版本，修改完后再推送给中央服务器。</p>
<p>分布式：每个人的电脑上都是一个完整的版本库，工作时不需要联网。和集中式相比，分布式版本控制系统的安全性要高很多，因为每个人电脑都有完整的版本库。</p>
<p>版本控制系统，只能跟踪文本文件的改动，比如TXT文件，网页，代码等，图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>此处省略几百字……</p>
<p>安装完成之后，需要设置用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"your name"</span></div><div class="line">git config --global user.email <span class="string">"email@example.com"</span></div></pre></td></tr></table></figure>
<p><code>--global</code>表示这台机器所有Git仓库都使用这个用户名和邮箱，也可以对某个仓库指定不同的用户名和Email地址。</p>
<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>使用<code>git init</code>命令，把当前的目录变成Git可以管理的仓库</p>
<ul>
<li><p>使用<code>git add &lt;file&gt;</code>，将文件添加到暂存区<br>  <code>git add readme.md</code></p>
</li>
<li><p>使用<code>git commit</code>，将文件添加到版本库<br>  <code>git commit -m &#39;add some files&#39;</code>，<code>-m</code>后面输入的是本次提交的说明</p>
</li>
</ul>
<h4 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h4><ul>
<li>工作区（Working Directory）<br>  电脑里能看到的目录</li>
<li>版本库（Repository）<br>  工作区有一个隐藏目录<code>.git</code>，是Git的版本库。<br>  <img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt=""><br>  其中stage（或者叫index）称之为暂存区。Git会为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code><br>  使用<code>git add</code>命令，实际上就是把文件修改添加到暂存区<br>  使用<code>git commit</code>命令，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ul>
<h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>使用<code>git status</code>查看文件当前处于什么状态，使用<code>git diff</code>查看工作区的修改内容</p>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p><code>git log</code>命令查看从最近到最远的提交日志，加上<code>--pretty=oneline</code>参数，每条日志以一行显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git log</div><div class="line">commit d1f725dfb4d7b59b4eaa6aafeac92599c33dd8c4 (HEAD -&gt; master)</div><div class="line">Author: gangxiaoya &lt;1335334055@qq.com&gt;</div><div class="line">Date:   Thu Apr 5 02:42:16 2018 -0700</div><div class="line"></div><div class="line">    word and add infos</div><div class="line"></div><div class="line">$ git log --pretty=oneline</div><div class="line">d1f725dfb4d7b59b4eaa6aafeac92599c33dd8c4 (HEAD -&gt; master) word and add infos</div></pre></td></tr></table></figure>
<p>类似<code>d1f725...8c4</code>是<code>commit-id</code>（版本号）。版本回退，<code>Git</code>需要知道回退到哪个版本。在<code>Git</code>中，<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>表示上上个版本，以此类推。当要回退之前多个版本，往上写多个<code>^</code>比较麻烦，可以用<code>HEAD~4</code>（<code>HEAD~number</code>）来表示。另外要回退到某个具体的版本，可以用<code>commit-id</code>来表示。</p>
<p><code>git reset</code>命令用来回退到某个版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//回退到上一个版本</div><div class="line">git reset --hard HEAD^</div><div class="line"></div><div class="line">git reset --hard HEAD~1</div><div class="line"></div><div class="line">//回退到commit-id为d1f725d的版本</div><div class="line">git reset --hard d1f725d</div></pre></td></tr></table></figure>
<p>当回退到之前的某个版本后，又想重新回到新版，可以用<code>git reflog</code>查看命令历史，找到未来某个版本的<code>commit-id</code>回退即可。</p>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>Git跟踪并管理的是修改，而非文件。使用<code>git add</code>命令后，会把工作区的修改存入暂存区。使用<code>git commit</code>命令，会把暂存区的修改提交到当前分支。假设第一次使用<code>git add</code>后，对工作去进行了第二次修改，然后<code>git commit</code>，提交的是第一次修改，第二次修改不会被提交。</p>
<p>使用<code>git diff HEAD</code>可以查看当前工作区和版本库里面最新版本的区别</p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><ul>
<li><p>撤销工作区修改<br>  使用<code>git checkout -- &lt;file&gt;</code>把文件在工作区的修改全部撤销。当文件还未提交到暂存区，撤销修改就回到和版本库一样。当文件已经提交到暂存区，然后又做了修改，撤销修改就回到添加到暂存区后的状态。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- readme.md</div></pre></td></tr></table></figure>
</li>
<li><p>撤销暂存区修改<br>  使用<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，<strong>重新放回工作区</strong>，如果想丢弃修改，再用<code>git checkout -- &lt;file&gt;</code>操作。</p>
</li>
<li><p>撤销版本库修改，按版本回退操作。</p>
</li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>本地仓库与远程仓库的连接，需要生成SSH key<br><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><br>然后在用户主目录下的<code>.ssh</code>目录下，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，把公钥添加远程Git服务器就好了。</p>
<ul>
<li>关联远程仓库<br>  <code>git remote add origin &lt;repo&gt;</code>将一个本地仓库关联到远程仓库</li>
<li>推送<br>  <code>git push -u origin master</code>将本地库推送到远程，使用<code>git push</code>命令，这里其实是将<code>master</code>分支推送到远程。第一次推送时，由于远程仓库是空的，加了<code>-u</code>参数，将本地<code>master</code>推送远程<code>master</code>并与之关联，后面就可以简化命令<code>git push origin master</code></li>
<li>克隆仓库<br>  <code>git clone &lt;repo&gt;</code>将一个远程仓库克隆到本地，repo表示一个远程仓库地址。</li>
</ul>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>Git中，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。在只有一条时间线仓库里，这个分支叫主分支，即<code>master</code>分支。开发中，一般会从主分支创建一个分支出来，开发完成后，再合并到主分支。</p>
<h4 id="创建与合并"><a href="#创建与合并" class="headerlink" title="创建与合并"></a>创建与合并</h4><ul>
<li>创建一个分支<code>git branch &lt;name&gt;</code></li>
<li>切换到某个分支<code>git checkout &lt;name&gt;</code></li>
<li>创建并切换到分支<code>git checkout -b &lt;name&gt;</code><br>  <code>git checkout -b dev</code>表示创建一个<code>dev</code>分支，并且切换到该分支。相当于先<code>git branch dev</code>创建<code>dev</code>分支，然后<code>git checkout dev</code>切换到<code>dev</code>分支</li>
<li>查看分支<code>git branch</code>，当前分支前面会标一个<code>*</code>号</li>
<li><p>合并分支<code>git merge</code>合并指定分支到当前分支<br>  <code>git merge dev</code>在<code>master</code>分支上执行这个命令，相当于把<code>dev</code>分支合并到<code>master</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Updating 76476ff..fb48436</div><div class="line">Fast-forward</div><div class="line">readme.md | 3 ++-</div><div class="line">1 file changed, 2 insertions(+), 1 deletion(-)</div></pre></td></tr></table></figure>
<p>  其中<code>Fast-forward</code>表示合并采用的是”快进模式“，直接把<code>master</code>指向<code>dev</code>的提交</p>
<blockquote>
<p>通常情况，Git会采用<code>Fast-forward</code>模式，但这种模式，删除分支后，会丢失分支信息。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit。可以在合并时添加参数<code>--no-ff</code>禁用，例如<code>git merge --no-ff -m &#39;merge with no ff&#39; dev</code>。</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="external">变基<code>git rebase</code></a></p>
</blockquote>
</li>
<li>删除分支<code>git branch -d &lt;name&gt;</code>，未被合并的分支，删除需要使用<code>git branch -D &lt;name&gt;</code></li>
</ul>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>当从主分支切了一个分支出来，开发完成后，准备合并到主分支，如果主分支也有新的提交，这种情况可能无法进行自动合并时，就需要手动解决冲突。解决冲突后，再提交，合并完成。</p>
<p>可以使用<code>git log --graph</code>命令可以看到分支合并图</p>
<h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>当有紧急需求需要处理时，而当前分支功能的开发又未完成，可以使用<code>stash</code>功能，将当前的工作区暂存起来，以后恢复继续开发。</p>
<ul>
<li><code>git stash</code>，保存现场。</li>
<li><p><code>git stash list</code>，查看<code>stash</code>列表，可以多次<code>stash</code>，这样会有多个<code>stash</code>。如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stash@&#123;0&#125;: WIP on dev: 92f946c not use ff</div><div class="line">stash@&#123;1&#125;: WIP on dev: 92f946c not use ff</div></pre></td></tr></table></figure>
</li>
<li><p><code>git stash apply</code>，恢复最新的<code>stash</code>，可以恢复指定的<code>stash</code>，如<code>git stash apply stash@{1}</code>。</p>
</li>
<li><code>git stash drop</code>，删除最新<code>stash</code>。可以删除指定的<code>stash</code>，如<code>git stash drop stash@{1}</code>。</li>
<li><code>git stash pop</code>，恢复同时删除<code>stash</code>。可以恢复同时删除指定的<code>stash</code>，如<code>git stash pop stash@{1}</code>。</li>
</ul>
<h4 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>查看远程仓库信息，可以使用<code>git remote</code>，更详细的信息可以使用<code>git remote -v</code>，远程仓库默认名称是<code>origin</code>。如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line"></div><div class="line">origin	git@****.git (fetch)</div><div class="line">origin	git@****.git (push)</div></pre></td></tr></table></figure></p>
<ul>
<li>推送分支<br>  把本地分支推送到远程仓库<code>git push origin &lt;name&gt;</code>，如把<code>dev</code>分支推动到远程仓库<code>git push origin dev</code></li>
<li>抓取分支<br>  当一个分支，多人有提交，远程仓库比本地更新，推送到远程仓库，需要先拉取该分支的最新代码并且合并到本地，如果有冲突，解决完冲突后，再推送。可以使用<code>git pull &lt;remote&gt; &lt;name&gt;</code>拉取远程某个分支代码并合并，如<code>git pull origin dev</code>。<blockquote>
<p><code>git fetch</code>从远程获取最新版本到本地，不会自动<code>merge</code>。</p>
</blockquote>
</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>发布一个版本时，通常会在版本库打一个标签，标签其实就是指向某个<code>commit</code>的指针。</p>
<ul>
<li>打标签，切换到需要打标签的分支，使用<code>git tag &lt;name&gt;</code>就可以打一个新的标签。如<code>$ git tag v1.0.0</code></li>
<li>查看所有标签，使用<code>git tag</code></li>
<li><p>查看标签信息，使用<code>git show &lt;tagname&gt;</code>，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git show v1.0.0</div><div class="line"></div><div class="line">commit 607a3d2d476749cef1d20a1b66606add5a125ec9 (HEAD -&gt; master, tag:v1.0.0, hotfix-bug)</div><div class="line">Author: ***</div><div class="line">Date:   Sun Apr 8 05:24:47 2018 -0700</div></pre></td></tr></table></figure>
</li>
<li><p>新建的标签默认是指向<code>HEAD</code>，也可以指向某个<code>commit</code>，使用<code>git tag &lt;name&gt; commit-id</code>。如<code>git tag v1.0.1 92f946c</code>。</p>
</li>
<li>删除标签，使用<code>git tag -d &lt;name&gt;</code></li>
<li>将标签推送到远程仓库<code>git push origin &lt;name&gt;</code>，这些和分支的操作是类似。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>线上版本回滚<br>  <code>git reset --hard v1.0.0</code><br>  <code>git reset --soft origin/master</code><br>  <code>git commit -am &#39;revert to v1.0.0&#39;</code></p>
</li>
<li><p>删除远程分支<br>  可以运行带有<code>--delete</code> 选项的<code>git push</code>命令来删除一个远程分支，比如删除远程<code>dev</code>分支，<code>$ git push origin --delete dev</code></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/《深入理解ES6》之扩展对象的功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/《深入理解ES6》之扩展对象的功能/" itemprop="url">《深入理解ES6》之扩展对象的功能</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T03:02:40+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><p>ES6规范清晰定义了每一个类别的对象</p>
<ul>
<li><strong>普通对象</strong>  具有JavaScript对象所有的默认行为</li>
<li><strong>特异对象</strong>  具有某些与默认行为不符的内部行为</li>
<li><strong>标准对象</strong>  ES6规范中定义的对象，例如<code>Array</code>、<code>Date</code>等。标准对象既可以是普通对象，也可以是特异对象。</li>
<li><strong>内建对象</strong>  脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象。</li>
</ul>
<h3 id="对象字面量语法扩展"><a href="#对象字面量语法扩展" class="headerlink" title="对象字面量语法扩展"></a>对象字面量语法扩展</h3><h4 id="属性初始值的简写"><a href="#属性初始值的简写" class="headerlink" title="属性初始值的简写"></a>属性初始值的简写</h4><p>当一个对象的属性与本地变量名同名时，不必再写冒号和值，简单的写属性名即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="comment">// function createPerson(name, age)&#123;</span></div><div class="line"><span class="comment">//     return &#123;</span></div><div class="line"><span class="comment">//         name: name,</span></div><div class="line"><span class="comment">//         age: age</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name,</div><div class="line">        age</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找同名变量。如果找到，则变量的值被赋给对象字面量里的同名属性。</p>
<h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><p>之前的版本，如果为对象添加方法，必须通过指定名称并完整定义函数来实现。再ES6中，语法更加简洁，消除了冒号和关键字<code>function</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="comment">// var person = &#123;</span></div><div class="line"><span class="comment">//     name: 'Nicholas',</span></div><div class="line"><span class="comment">//     sayName: function() &#123;</span></div><div class="line"><span class="comment">//         console.log(this.name);</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">'Nicholas'</span>,</div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><p>在ES5及早期版本中，引用属性，有点方法和方括号方法。当引用一个通过计算得到的属性名或者改属性名是一个非法的标识符（数字，字母，下划线，美元符，数字不能开头），只能使用方括号方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;,</div><div class="line">    lastName = <span class="string">'last name'</span>;</div><div class="line"></div><div class="line">person[<span class="string">'first name'</span>] = <span class="string">'Nicholas'</span>;</div><div class="line">person[lastName] = <span class="string">'Zakas'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]); <span class="comment">//'Nicholas'</span></div><div class="line"><span class="built_in">console</span>.log(person[lastName]);  <span class="comment">//'Zakas'</span></div></pre></td></tr></table></figure></p>
<p>在对象字面量中，可以直接使用字符串字面量作为属性名称（如果包含非法的标识符，属性名加引号）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">'first name'</span>: <span class="string">'Nicholas'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]); <span class="comment">//'Nicholas'</span></div></pre></td></tr></table></figure></p>
<p>如果属性名称<code>first name</code>被包含在一个变量中，或者需要通过计算才能得到该变量的值，那么在ES5是无法为一个对象字面量定义该属性。</p>
<p>在ES6中，可以在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同使用方括号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> lastName = <span class="string">'last name'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    <span class="string">'first name'</span>: <span class="string">'Nicholas'</span>,</div><div class="line">    [lastName]: <span class="string">'Zakas'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]);  <span class="comment">//'Nicholas'</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>]);  <span class="comment">//'Zakas'</span></div></pre></td></tr></table></figure></p>
<p>在对象字面量中使用方括号表示的该属性名称是可计算的，他的内容将被求值最终转化为一个字符串，所以可以使用表达式作为属性的可计算名称<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> suffix = <span class="string">'name'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    [<span class="string">'first '</span> + suffix]: <span class="string">'Nicholas'</span>,</div><div class="line">    [<span class="string">'last '</span> + suffix]: <span class="string">'Zakas'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'first name'</span>]);  <span class="comment">//'Nicholas'</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">'last name'</span>]);  <span class="comment">//'Zakas'</span></div></pre></td></tr></table></figure></p>
<p>任何可用于对象实例括号记法的属性名，也可以作为对象字面量中的计算属性名。</p>
<h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><h4 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is()方法"></a>Object.is()方法</h4><p>在JavaScript中比较两个值时，可以使用相等运算符（<code>==</code>）或全等运算符（<code>===</code>），前者会触发强制类型转换。但是全等运算符也不完全准确，比如+0和-0，使用全等运算符<code>===</code>进行比较，等到的是两者相等。</p>
<p>ES6中引入<code>Object.is()</code>方法来弥补全等运算符的不准确运算。改方法接受两个参数，如果这两个参数类型并且值相同，则返回<code>true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> == +<span class="number">0</span>);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> === +<span class="number">0</span>); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>,+<span class="number">0</span>));  <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);    <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);   <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));   <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a>Object.assign()方法</h4><p><code>Object.assign</code>用来实现一个对象接收其他对象的属性和方法，可以接受任意数量的源对象，并按指定顺序将属性复制到接收对象中。如果有同名属性，排位靠后的源对象会覆盖前面的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(receiver, </div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'js'</span>,</div><div class="line">        name: <span class="string">'file.js'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'css'</span></div><div class="line">    &#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(receiver.type); <span class="comment">//'css'，后面同名属性覆盖前面</span></div><div class="line"><span class="built_in">console</span>.log(receiver.name); <span class="comment">//'file.js'</span></div></pre></td></tr></table></figure>
<p><code>Object.assign()</code>方法不能将提供者的访问器属性复制到接收对象中。<code>Object.assign()</code>方法执行的式赋值操作，所以访问器属性最终会转变为接收对象中的一个数据属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> receiver = &#123;&#125;,</div><div class="line">    supplier = &#123;</div><div class="line">        get name()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'file.js'</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(receiver, supplier);</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">'name'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.value);  <span class="comment">//'file.js'</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.get);    <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<h3 id="重复的对象字面量属性"><a href="#重复的对象字面量属性" class="headerlink" title="重复的对象字面量属性"></a>重复的对象字面量属性</h3><p>ES5中严格模式会对对象字面量的重复属性进行校验，存在重复同名属性时抛出错误。ES6中，无论严格模式还是非严格模式，不再检查重复属性，对于重复属性，都会选取最后一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">'Nicholas'</span>,</div><div class="line">    name: <span class="string">'Greg'</span>    <span class="comment">//ES6严格模式下没有错误</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name);   <span class="string">'Greg'</span></div></pre></td></tr></table></figure>
<h3 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h3><p>ES6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到<code>Object.getOwnPropertyNames()</code>以及<code>Reflect.ownKeys</code>返回属性的方式，<code>Object.assign()</code>方法处理属性的顺序也将随之改变。规则是</p>
<ul>
<li>所有数字键按升序拍讯</li>
<li>所有字符串键按照它们被加入对象的顺序排序</li>
<li>所有<code>symbol</code>键按照他们被加入对象的顺序排序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    <span class="number">2</span>: <span class="number">1</span>,</div><div class="line">    c: <span class="number">1</span>,</div><div class="line">    <span class="number">1</span>: <span class="number">1</span></div><div class="line">&#125;</div><div class="line">obj.b = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">''</span>));  <span class="comment">//12acb</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>for-in</code>循环，没有一个明确的枚举顺序。<code>Object.keys()</code>和<code>JSON.stringify()</code>方法和<code>for-in</code>使用相同的枚举顺序。</p>
</blockquote>
<h3 id="增加对象原型"><a href="#增加对象原型" class="headerlink" title="增加对象原型"></a>增加对象原型</h3><h4 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h4><p>正常情况下，无论是通过构造函数还是<code>Object.create()</code>方法创建对象，其原型是在对象被创建时指定的。在ES5中缺少对象在实例化后改变原型的标准方法。</p>
<p>ES6中，添加了<code>Object.setPrototypeof()</code>方法，通过该方法可以改变指定对象的原型，它接受两个参数，被改变原型的对象以及替代第一个参数原型的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> dog = &#123;</div><div class="line">    getGreeting()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'woof'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person); </div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());  <span class="comment">//'hello'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());  <span class="comment">//'woof'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h4 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h4><p>ES6引入<code>Super</code>关键字，<code>Super</code>引用相当于指向对象原型的指针，他可以便捷访问对象原型。比如需要重写对象实例的方法，有需要调用与它同名的原型方法，ES5中可以实现如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> dog = &#123;</div><div class="line">    getGreeting()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'woof'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">', hi'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//将原型设置为person</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());</div><div class="line"></div><div class="line"><span class="comment">//将原型设置为dog</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());</div></pre></td></tr></table></figure></p>
<p>示例中，<code>friend</code>对象的<code>getGreeting()</code>调用了同名的原型方法。<code>Object.getPrototypeOf()</code>方法确保调用正确的原型，<code>call(this)</code>确保正确设置原型方法中的<code>this</code></p>
<p>ES6中，可以简化上面的<code>getGreeting()</code>方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="comment">// return Object.getPrototypeOf(this).getGreeting.call(this) + ', hi';</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Super</code>引用必须要在使用简写方法的对象中使用，如果在其他方法声明中使用会导致错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//语法错误</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h3><p>ES6中正式将方法定义为一个函数，他会有一个内部的[[HomeObject]]属性来容纳这个方法从属的对象。<code>Super</code>的所有引用都通过[[HomeObject]]属性来确定。首先是在[[HomeObject]]属性上调用<code>Object.getPrototypeOf()</code>方法来检索原型的引用，然后搜索原型找到同名函数，最后设置<code>this</code>绑定并且调用相应的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// return Object.getPrototypeOf(this).getGreeting.call(this) + ', hi';</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">', hi'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());</div></pre></td></tr></table></figure></p>
<p>示例中，<code>friend.getGreeting()</code>方法的[[HomeObject]]属性值是<code>friend</code>，<code>friend</code>的原型是<code>person</code>，所以<code>super.getGreeting()</code>等价于<code>person.getGreeting.call(this)</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/相等操作符（==）的隐式转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/相等操作符（==）的隐式转换/" itemprop="url">相等操作符（==）的隐式转换</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T04:21:02+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="相等操作符（-）的隐式转换"><a href="#相等操作符（-）的隐式转换" class="headerlink" title="相等操作符（==）的隐式转换"></a>相等操作符（==）的隐式转换</h2><p>使用相等操作符，当两个操作数类型不相等时，会在比较前尝试将其转换为相同类型。转换规则如下</p>
<ul>
<li>数字和字符串比较，字符串会转换成数字值（<code>ToNumber</code>）</li>
<li>其中一个操作数为布尔值，会将布尔值转换为数值，如果为<code>true</code>则转换为<code>1</code>，如果为<code>false</code>则转换为<code>0</code></li>
<li><code>null == undefined</code>和<code>undefined == null</code>返回<code>true</code></li>
<li>一个对象和数字或字符串比较，JavaScript会尝试返回对象的默认值。操作符会尝试通过<code>valueOf</code>和<code>toString</code>将对象转换成原始值（<code>ToPrimitive</code>）</li>
<li>两个操作数均为对象，当它们的引用相同则返回<code>true</code></li>
</ul>
<blockquote>
<p><code>NaN == NaN;   //false +0 == -0;   //true</code> </p>
<p>原始数据 （原始值、原始数据类型）是一个非 <code>object</code> 类型并且没有自己的方法的数据。在 JavaScript 中，有六种原始数据类型：<code>string</code>，<code>number</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>，<code>symbol</code>。除了<code>null</code>和<code>undefined</code>，所有原始值都有包裹这个原始值的等价对象，这个包裹对象的<code>valueOf()</code>方法返回原始值。</p>
</blockquote>
<h3 id="ToNumber和ToPrimitive"><a href="#ToNumber和ToPrimitive" class="headerlink" title="ToNumber和ToPrimitive"></a><code>ToNumber</code>和<code>ToPrimitive</code></h3><p>上述转换涉及到两个内部的方法<code>ToNumber</code>和<code>ToPrimitive</code>。</p>
<h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a><code>ToNumber</code></h4><p><code>ToNumber</code>方法对不同类型返回结果如下</p>
<ul>
<li>布尔值，<code>true</code>–&gt;<code>1</code>，<code>false</code>–&gt;<code>+0</code></li>
<li><code>undefined</code>–&gt;<code>NaN</code></li>
<li><code>null</code>–&gt;<code>+0</code></li>
<li>数字，数字对应值</li>
<li>字符串，<strong>只包含</strong>有效数字格式字符串，转换为对应十进制数值（空字符转化为<code>0</code>），其他转换为<code>NaN</code>。<ul>
<li>字符串只包含数字（包括前面正负号）字符串’123’–&gt;<code>123</code>，’011’–&gt;<code>11</code>（前导零忽略）</li>
<li>字符串是有效的浮点数，转换为对应的浮点数值</li>
<li>字符串是有效的十六进制’0x12’–&gt;<code>18</code></li>
</ul>
</li>
<li>对象，<code>ToNumber(ToPrimitive(value, Number))</code><blockquote>
<p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.3" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/5.1/#sec-9.3</a></p>
</blockquote>
</li>
</ul>
<h4 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a><code>ToPrimitive</code></h4><p><code>ToPrimitive(input, [PreferredType])</code>将<em>input</em>转换成原始值，如果一个对象可以转换成多种原始值，可以通过<em>PreferredType</em>转换成指定类型。</p>
<p><code>ToPrimitive</code>转换规则如下</p>
<ul>
<li><code>input</code>为原始值，则返回输入值</li>
<li><code>input</code>为对象，则需要通过<em>PreferredType</em>来确定</li>
</ul>
<h5 id="PreferredType设置为String"><a href="#PreferredType设置为String" class="headerlink" title="PreferredType设置为String"></a>PreferredType设置为String</h5><ul>
<li>调用该对象<code>toString</code>方法，结果是原始值，则返回结果</li>
<li>调用该对象<code>valueOf</code>方法，结果是原始值，则返回结果</li>
<li>抛出<code>TypeError</code>异常</li>
</ul>
<h5 id="PreferredType设置为Number"><a href="#PreferredType设置为Number" class="headerlink" title="PreferredType设置为Number"></a>PreferredType设置为Number</h5><ul>
<li>调用该对象<code>valueOf</code>方法，结果是原始值，则返回结果</li>
<li>调用该对象<code>toString</code>方法，结果是原始值，则返回结果</li>
<li>抛出<code>TypeError</code>异常</li>
</ul>
<p>当<em>PreferredType</em>没有设置值时，如果该对象为<code>Date</code>类型，行为与设置String一致，其他与设置Number一致。</p>
<blockquote>
<p><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.1" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/5.1/#sec-9.1</a><br><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8</a></p>
</blockquote>
<h3 id="valueOf和toString方法"><a href="#valueOf和toString方法" class="headerlink" title="valueOf和toString方法"></a><code>valueOf</code>和<code>toString</code>方法</h3><p><code>Object.prototype</code>包含<code>valueOf</code>和<code>toString</code>这两个方法，所以继承至<code>Object</code>的对象都可以调用（如果对象重写了该方法，则调用自身）。</p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a><code>valueOf</code></h4><p>JavaScript的内置对象都重写了<code>valueOf</code>方法，以实现更适合自身的功能需要。常见的返回值如下</p>
<ul>
<li>对象有原始值（<code>number</code>,<code>string</code>,<code>boolean</code>,<code>symbol</code>），返回原始值</li>
<li><code>Date</code>对象，返回毫秒数（UTC）</li>
<li>其他，返回对象本身</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(num.valueOf());     <span class="comment">//123</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.valueOf());     <span class="comment">//'hello'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(bool.valueOf());    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> syb = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="built_in">console</span>.log(syb.valueOf());     <span class="comment">//Symbol(foo)</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="string">'abc'</span>, <span class="number">1</span>, <span class="number">6</span>];</div><div class="line"><span class="built_in">console</span>.log(arr.valueOf() === arr);     <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo.valueOf() === foo);     <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/.+/</span>);</div><div class="line"><span class="built_in">console</span>.log(reg.valueOf() === reg);     <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'张三'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.valueOf() === obj);     <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><code>toString</code></h4><p>调用<code>toString</code>返回值如下</p>
<ul>
<li>该对象重写了<code>toString</code>方法，如<code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Array</code>、<code>Date</code>、<code>Function</code>、<code>RegExp</code></li>
<li><code>null</code>和<code>undefined</code>通过<code>call</code>调用<code>toString</code>（<code>Object.prototype.toString.call(null)</code>），分别返回<code>[object Null]</code>和<code>[object Undefined]</code></li>
<li>否则继承自<code>Object.prototype</code>，返回 <code>&#39;[object type]&#39;</code>，其中<code>type</code>是对象的类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));     <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">'toString'</span>)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> num = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toString());    <span class="comment">//'123'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> bol = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(bol.toString());    <span class="comment">//'true'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.toString());    <span class="comment">//'hello'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> syb = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="built_in">console</span>.log(syb.toString());     <span class="comment">//'Symbol(foo)'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="built_in">console</span>.log(date.toString());   <span class="comment">//'Sun Feb 25 2018 02:34:47 GMT-0800 (PST)' 返回一个美式英语日期格式的字符串</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo.toString());    <span class="comment">//'function ()&#123;&#125;' 返回表示当前函数源代码的字符串，包括 function关键字，形参列表，大括号，以及函数体中的内容</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/.+/</span>);</div><div class="line"><span class="built_in">console</span>.log(reg.toString());    <span class="comment">//'/.+/' 返回一个表示该正则表达式的字符串。</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [<span class="string">'abc'</span>, <span class="number">1</span>, <span class="number">6</span>];</div><div class="line"><span class="built_in">console</span>.log(arr.toString());    <span class="comment">//'abc,1,6' 返回值经调用 join() 方法连接（由逗号隔开）组成</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    name: <span class="string">'张三'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj.toString());    <span class="comment">//'[object Object]'</span></div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString</a></p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[] == !&#123;&#125;;  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<ul>
<li><code>!</code>优先级比<code>==</code>高，<code>!{}</code>结果为<code>false</code></li>
<li><code>[] == false</code>，其中一个操作数为布尔值，先将布尔值转为数值<code>ToNumber</code>，<code>false</code>转为数值结果为<code>0</code></li>
<li><code>[] == 0</code>，对象与数值比较，将对象转换为原始值<code>ToPrimitive(value, Number)</code>（<code>Date</code>类型<code>ToPrimitive(value, String)</code>）。</li>
<li>先调用<code>valueOf</code>方法，回返回<code>[]</code>本身，此时不是原始值，然后调用<code>toString</code>方法返回<code>&#39;&#39;</code>空</li>
<li><code>&#39;&#39; == 0</code>字符串与数值比较，字符串转换为数值<code>ToNumber</code>，空字符转换为数值结果为<code>0</code>，所以最终表达式为<code>0 == 0</code>，返回<code>true</code></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/28/《深入理解ES6》之函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/《深入理解ES6》之函数/" itemprop="url">《深入理解ES6》之函数</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T00:46:42+08:00">
                2018-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数形参的默认值"><a href="#函数形参的默认值" class="headerlink" title="函数形参的默认值"></a>函数形参的默认值</h3><p><code>JavaScript</code>函数语法规定，无论在函数定义中声明了多少形参，调用时可以传入任意数量的参数。可以在定义时，当已定义的形参无对应的传入参数时为其指定一个默认值。</p>
<h4 id="在ES5中模拟默认参数"><a href="#在ES5中模拟默认参数" class="headerlink" title="在ES5中模拟默认参数"></a>在ES5中模拟默认参数</h4><p>ES5和早期版本中，可能通过如下方法模拟默认参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>)</span>&#123;</div><div class="line">    timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">'undefined'</span>)? timeout: <span class="number">2000</span>;</div><div class="line">    callback = (<span class="keyword">typeof</span> callback !== <span class="string">'undefined'</span>)? callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">//函数其余部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例中，<code>timeout</code>和<code>callback</code>为可选参数，如果没有传入相应的参数，会有一个默认值。对于函数命名参数，如果不显示传值，默认为<code>undefined</code>。在模拟默认参数时，最好不要这样写<code>timeout = timeout || 2000</code>，因为，如果想给<code>timeout</code>传入0，即使这个值合法，也会被视为<code>false</code>，最终<code>timeout</code>赋值为2000。</p>
<h4 id="ES6中的默认参数"><a href="#ES6中的默认参数" class="headerlink" title="ES6中的默认参数"></a>ES6中的默认参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout=<span class="number">2000</span>, callback=function(</span>) </span>&#123;&#125;)&#123;</div><div class="line">    <span class="comment">//函数其余部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6简化了为形参提供默认参数的过程，声明函数时，可以为任意参数指定默认值，在已指定默认值的参数后面，可以继续声明无默认值参数。只有不为参数传入值或者 <strong>传入值为<code>undefined</code></strong> 时，对应参数才会使用默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用timeout默认值</span></div><div class="line">makeRequest(<span class="string">'/foo'</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params">body</span>)</span>&#123;</div><div class="line">    doSomething(body)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//使用timeout默认值</span></div><div class="line">makeRequest(<span class="string">'/foo'</span>)</div><div class="line"></div><div class="line"><span class="comment">//不使用timeout默认值</span></div><div class="line">makeRequest(<span class="string">'/foo'</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>)</span>&#123;</div><div class="line">    doSomething(body)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="默认参数值对arguments对象的影响"><a href="#默认参数值对arguments对象的影响" class="headerlink" title="默认参数值对arguments对象的影响"></a>默认参数值对arguments对象的影响</h4><p>在ES5非严格模式中，命名参数的变化会同步更新到<code>arguments</code>对象，严格模式中<code>arguments</code>对象不随命名参数变化而变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>)</span>&#123;</div><div class="line">    <span class="comment">// 'use strict'</span></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);  <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></div><div class="line">    first = <span class="string">'c'</span>;</div><div class="line">    second = <span class="string">'d'</span>;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//true</span></div><div class="line">&#125;</div><div class="line">mixArgs(<span class="string">'a'</span>, <span class="string">'b'</span>)；</div></pre></td></tr></table></figure></p>
<p>当定义为严格模式时，输出为<code>true</code>，<code>true</code>，<code>false</code>，<code>false</code></p>
<p>ES6中，函数使用了默认参数，无论是否显式定义了严格模式，<code>arguments</code>对象行为都与ES5中的严格模式保持一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second=<span class="string">'b'</span></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);  </div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">'c'</span>;</div><div class="line">    second = <span class="string">'d'</span>;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line">mixArgs(<span class="string">'a'</span>)</div></pre></td></tr></table></figure></p>
<p>以上输出为<code>true</code>，<code>false</code>，<code>false</code>，<code>false</code>，<code>first</code>和<code>second</code>并不会影响<code>arguments</code>对象，其中<code>arguments[1]===undefined</code></p>
<h4 id="默认参数表达式"><a href="#默认参数表达式" class="headerlink" title="默认参数表达式"></a>默认参数表达式</h4><p>函数默认参数值非原始值传参时，默认参数是在函数调用时求值，也就是说在函数声明时，参数默认值是不确定的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value++</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>))</span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>));  <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));    <span class="comment">//6</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));    <span class="comment">//7</span></div></pre></td></tr></table></figure></p>
<p>示例中，调用<code>add</code>不给<code>second</code>传值，就会调用<code>getValue()</code>对<code>second</code>求默认值，所以任何时候都可以改变默认值。</p>
<p>因为默认参数是函数调用时求值，所以可以使用<strong>先定义的参数</strong>做为后定义参数的默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));</div></pre></td></tr></table></figure></p>
<p>先定义的参数访问了后定义的参数，会抛出错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first=second, second</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>));  <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">//抛出错误</span></div></pre></td></tr></table></figure></p>
<p>这是由于函数参数有自己的临时死区，定义参数时会为每个参数创建一个新的标识符绑定，该绑定在初始化之前不可被引用。</p>
<p>上面示例中调用<code>add(1, 1)</code>和<code>add(undefined, 1)</code>时，相当于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用add(1, 1)</span></div><div class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">//调用add(undefined, 1)</span></div><div class="line"><span class="keyword">let</span> first = second;</div><div class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>当<code>first</code>初始化时<code>second</code>尚未初始化，此时<code>second</code>处于临时死区中，所以会导致程序抛出错误。</p>
<h3 id="处理无命名参数"><a href="#处理无命名参数" class="headerlink" title="处理无命名参数"></a>处理无命名参数</h3><p>早先，利用<code>arguments</code>来检查函数的所有参数，而不必定义每个要用的参数。ES6中，通过引入不定参数的特性来解决这些问题。</p>
<h4 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h4><p>在函数的命名参数前添加三个点（<code>...</code>）就表明这是一个不定参数，该参数是一个数组，包含着自它之后传入的所有参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++)&#123;</div><div class="line">        result[keys[i]] = object[keys[i]]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> book = &#123;</div><div class="line">    title: <span class="string">'Understanding ECMAScript 6'</span>,</div><div class="line">    author: <span class="string">'Nicholas C. Zakas'</span>,</div><div class="line">    year: <span class="number">2016</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">'author'</span>, <span class="string">'year'</span>)</div><div class="line"><span class="built_in">console</span>.log(bookData.author);  <span class="comment">//'Nicholas C. Zakas'</span></div><div class="line"><span class="built_in">console</span>.log(bookData.year);     <span class="comment">//2016</span></div></pre></td></tr></table></figure></p>
<p>不定参数<code>keys</code>包含的是<code>object</code>之后传入的所有参数。</p>
<blockquote>
<p>函数的<code>length</code>属性统计的是函数命名参数的数量，不包括不定参数。<code>pick.length=1</code></p>
</blockquote>
<p>注意</p>
<ul>
<li><p>每个函数最多只能声明一个不定参数，而且要放在所有参数的末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法错误：不定参数后不能有其他命名参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys, last</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++)&#123;</div><div class="line">        result[keys[i]] = object[keys[i]]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不定参数不能用户对象字面量<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="external">setter</a>之中，因为对象字面量<code>setter</code>的参数有且只能有一个。</p>
</li>
<li>无论是否使用不定参数，<code>arguments</code>对象总是包含所有传入函数的参数。</li>
</ul>
<h3 id="增强的Function构造函数"><a href="#增强的Function构造函数" class="headerlink" title="增强的Function构造函数"></a>增强的Function构造函数</h3><p><code>Function</code>构造函数通常用来动态创建新的函数，该构造函数接受字符串形式的参数，分别为函数的参数及函数体。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'return first + second'</span>);</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>ES6增强了<code>Function</code>构造函数的功能，支持在创建函数时定义默认参数和不定参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'first'</span>, <span class="string">'second = first'</span>, <span class="string">'return first + second'</span>);</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));    <span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'...args'</span>, <span class="string">'return args[0]'</span>);</div><div class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h3><p>展开运算符可以将一个数组打散后作为各自独立的参数传入函数。例如，要从一个数组的中找出最大值，我们可以利用<code>Math.max()</code>方法，但<code>Math.max()</code>方法不允许传入数组。在ES5及早期版本，可能实现如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values)); <span class="comment">//100</span></div></pre></td></tr></table></figure></p>
<p>在ES6中，在数组前添加<code>...</code>符号，就会将参数数组分割为各自独立的参数依次传入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));  <span class="comment">//100</span></div></pre></td></tr></table></figure></p>
<p>此外，展开运算符还可以与其他正常传入的参数混合使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">-25</span>, <span class="number">50</span>, <span class="number">-75</span>, <span class="number">100</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>)); <span class="comment">//100</span></div></pre></td></tr></table></figure></p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>ES6给所有函数新增了<code>name</code>属性，用来辨别函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//空函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//空函数</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(doSomething.name);  <span class="comment">// 'doSomething'</span></div><div class="line"><span class="built_in">console</span>.log(doAnotherThing.name);  <span class="comment">//'doAnotherThing'</span></div></pre></td></tr></table></figure></p>
<p>函数声明函数<code>name</code>属性对应着声明时的函数名称，匿名函数表达式函数<code>name</code>属性对应着被赋值变量的名称。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//空函数</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    get firstName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'Nicholas'</span></div><div class="line">    &#125;,</div><div class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</div><div class="line"><span class="built_in">console</span>.log(doSomething.name);  <span class="comment">//'doSomethingElse'</span></div><div class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">//'sayName'</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.get.name);   <span class="comment">//'get firstName'</span></div></pre></td></tr></table></figure></p>
<p>函数表达式有一个名字，该名字比函数本身被赋值的变量权重高，所以<code>doSomething.name</code>的值为<code>doSomethingElse</code>。<code>firstName</code>是一个<code>getter</code>函数，他的名称会有<code>get</code>前缀，<code>setter</code>函数名称也有前缀<code>set</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//空函数</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(doSomething.bind().name);   <span class="comment">//'bound doSomething'</span></div><div class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">//'anonymous'</span></div></pre></td></tr></table></figure></p>
<p>通过<code>bind()</code>函数创建的函数，其名称带有’bound’前缀，使用<code>Function</code>构造函数创建的函数，其名称为’anonymous’。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name</a></p>
</blockquote>
<h3 id="明确函数的多重用途"><a href="#明确函数的多重用途" class="headerlink" title="明确函数的多重用途"></a>明确函数的多重用途</h3><p>ES5及早起版本，函数具有多重功能，可以结合<code>new</code>作为构造函数使用，返回一个对象。</p>
<p>函数有两个不同的内部方法：<code>[[Call]]</code>和<code>[[Construct]]</code>。通过<code>new</code>关键字调用函数时，执行的是<code>[[Construct]]</code>函数，它负责创建实例，然后执行函数体，将<code>this</code>绑定到实例上。如果不是通过<code>new</code>关键字调用，则执行<code>[[Call]]</code>函数，从而执行代码中的函数体。</p>
<p>具有<code>[[Construct]]</code>方法的函数统称为构造函数，不是所有函数都有<code>[[Construct]]</code>方法，比如箭头函数。</p>
<h4 id="ES5中判断函数是否作为构造函数调用"><a href="#ES5中判断函数是否作为构造函数调用" class="headerlink" title="ES5中判断函数是否作为构造函数调用"></a>ES5中判断函数是否作为构造函数调用</h4><p>在ES5中，判断函数是否通过<code>new</code>关键字被调用，流行的方式如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须通过new关键字来调用Person'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>);</div><div class="line"><span class="keyword">var</span> notAPerson1 = Person(<span class="string">'Nicholas'</span>); <span class="comment">//抛出错误</span></div><div class="line"><span class="comment">//var notAperson = Person.call(person, 'Michael')； //有效</span></div></pre></td></tr></table></figure></p>
<p>这个方法并不完全可靠，因为可以通过<code>call()</code>或者<code>apply()</code>方法将<code>this</code>绑定到<code>Person</code>的实例上。</p>
<h4 id="元属性new-target"><a href="#元属性new-target" class="headerlink" title="元属性new.target"></a>元属性new.target</h4><p>元属性是指非对象属性，其可以提供非对象目标的补充信息（例如<code>new</code>）。当函数调用<code>[[Construct]]</code>方法时，<code>new.target</code>被赋值为<code>new</code>操作符的目标，通常是新创建实例的构造函数。当函数调用<code>[[Call]]</code>方法，则<code>new.target</code>的值为<code>undefined</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须通过new关键字来调用Person'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>);</div><div class="line"><span class="keyword">var</span> notAperson = Person.call(person, <span class="string">'Michael'</span>);  <span class="comment">//抛出错误</span></div></pre></td></tr></table></figure></p>
<p>也可以检查是否被某个特定构造函数所调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target === Person)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须通过new关键字来调用Person'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    Person.call(<span class="keyword">this</span>, name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>);</div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">'Nicholas'</span>); <span class="comment">//抛出错误</span></div></pre></td></tr></table></figure></p>
<p><code>new AnotherPerson(&#39;Nicholas&#39;)</code>调用时，真正的调用<code>Person.call(this, name)</code>没有使用关键词，因此<code>new.target</code>的值为<code>undefined</code>抛出错误。</p>
<h3 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h3><p>ES5中，严格模式下，当在代码块内部声明函数时，程序抛出错误。ES6中，严格模式，在代码块中的声明的函数，会被提升块级作用域顶部，函数表达式不会被提升，一旦代码块结束执行，函数销毁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//'function'</span></div><div class="line">    <span class="comment">//console.log(typeof doAnotherThing); //抛出错误</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//空函数</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//空函数</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//'undefined'</span></div></pre></td></tr></table></figure></p>
<p>当执行到<code>typeof doAnotherThing</code>时，由于尚未执行<code>let</code>语句声明，<code>doAnotherThing</code>还在当前块作用域的临时死区，程序被迫终端执行。</p>
<blockquote>
<p>ES6规定，函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
</blockquote>
<p>非严格模式下，可以在外围函数或全局作用域访问和调用（定义后？）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//'undefined' node v8.9.0</span></div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//'function'</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//空函数</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);  <span class="comment">//'function'</span></div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是一种使用箭头（<code>=&gt;</code>）定义函数的新语法，它与以前的函数有些许不同。</p>
<ul>
<li>没有<code>this</code>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="external"><code>super</code></a>、<code>argument</code>和<code>new.target</code>绑定，这些值都由外围最近一层非箭头函数决定。</li>
<li>不能通过<code>new</code>关键字调用，因为箭头函数没有<code>[[Construct]]</code>方法。</li>
<li>没有原型，由于不能通过<code>new</code>关键字调用，因而没有构建原型的需求，所以箭头函数不存在<code>prototype</code>这个属性</li>
<li>不支持重复命名参数，无论在严格模式还是非严格模式。传统函数只有在严格模式下才不支持。</li>
</ul>
<h4 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h4><p>当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回。当箭头函数有多个参数时，要给参数加上括号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</div><div class="line"></div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"></div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当函数没有参数时，也要在声明的时候写一对空括号。当函数体有多个表达式时，需要用花括号包裹函数体，如果需要返回值，就得显示定义一个返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'Nicholas'</span>;</div><div class="line"></div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Nicholas'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> min = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>(num1 &gt; num2)&#123;</div><div class="line">        <span class="keyword">return</span> num2</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num1</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//相当于</span></div><div class="line"><span class="keyword">let</span> nim = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(num1 &gt; num2)&#123;</div><div class="line">        <span class="keyword">return</span> num2</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> num1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当函数体只有一个表达式，并且返回一个对象字面里时，需要将其包裹在小括号内，以区分函数体。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getTemItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;<span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">'Temp'</span>&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="尾调优化"><a href="#尾调优化" class="headerlink" title="尾调优化"></a>尾调优化</h3><p>尾调用指的是函数做为另一个函数的最后一条语句调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> doSomethingElse()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ES5的引擎中，尾调用的实现与其他函数调用的实现类似：创建一个新的栈帧，将其推入调用栈来表示函数调用。也就是说在循环调用中，每一个未用完的栈帧都会保存在内存中，当调用栈变得过大时会造成程序问题。</p>
<h4 id="ES6中的尾调优化"><a href="#ES6中的尾调优化" class="headerlink" title="ES6中的尾调优化"></a>ES6中的尾调优化</h4><p>ES6，在严格模式下，如果满足以下条件，JavaScript引擎自动优化（主要看引擎支持），尾调用不再创建新的栈帧，而是清除并重用当前栈帧。</p>
<ul>
<li>尾调用不妨问当前栈帧的变量（也就是说函数不是一个闭包）</li>
<li>在函数内部，尾调用时最后一条语句</li>
<li>尾调用结果作为函数值返回<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//优化后</span></div><div class="line">    <span class="keyword">return</span> doSomethingElse()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个函数中，尾调用<code>doSomethingElse</code>的结果立即返回，不调用任何局部作用域变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//无法优化，无返回</span></div><div class="line">    doSomethingElse()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数，不返回最终结果，无法被优化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//无法优化，返回值执行其他操作</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> + doSomethingElse()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在尾调用返回后执行其他操作，无法被优化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//无法优化，调用不再尾部</span></div><div class="line">    <span class="keyword">let</span> result = doSomethingElse()</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把函数调用的结果存储在一个变量里，最后再返回这个变量，由于没有立即返回<code>doSomethingElse</code>函数的值，无法被优化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> num = <span class="number">1</span>,</div><div class="line">        func = <span class="function"><span class="params">()</span> =&gt;</span> num;</div><div class="line">    <span class="comment">//无法优化，该函数是一个闭包</span></div><div class="line">    <span class="keyword">return</span> func();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>func</code>函数访问局部变量<code>num</code>，无法被优化</p>
<h4 id="利用尾调用优化"><a href="#利用尾调用优化" class="headerlink" title="利用尾调用优化"></a>利用尾调用优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//无法优化</span></div><div class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个阶乘函数，由于在递归调用前执行了乘法操作，所以阶乘函数无法被优化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, p = <span class="number">1</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> p * <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//优化后</span></div><div class="line">        <span class="keyword">let</span> result = n * p;</div><div class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>, result)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个重写后的<code>factorial</code>函数，参数<code>p</code>用来保存乘法结果，下一次迭代可以取出它用于计算。在线ES6引擎就可以优化递归调用了。</p>
<blockquote>
<p>ES6的尾调优化，最终还是取决于JavaScript引擎是否支持。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/《深入理解ES6》之字符串和正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/《深入理解ES6》之字符串和正则表达式/" itemprop="url">《深入理解ES6》之字符串和正则表达式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T02:47:35+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ES6之前，JavaScript字符串是基于16位字符编码(UTF-16)进行构建。每16位序列是一个编码单元，代表一个字符。<code>length</code>、<code>charAt()</code>等字符串属性和方法都是基于这种编码单元构造的。</p>
<h3 id="UTF-16码位"><a href="#UTF-16码位" class="headerlink" title="UTF-16码位"></a>UTF-16码位</h3><p>Unicode为每一个字符提供了唯一的标识符，又称为码位，它是从0开始的数值。而表示字符的这些数值或者码位，称之为字符编码。</p>
<p>在UTF-16中，前2^16个码位均以16位的编码单元表示，这个范围称作<strong>基本多文种平面</strong>（BMP）。超出这个范围的码位则要归属于某个辅助平面，因为用16位已经无法表示。为此，UTF-16引入了<em>代理对</em>，规定用两个16位编码单元表示一个码位。</p>
<p>所以，字符串有两种，一种是由一个编码单元16位表示的BMP字符，另一种是有两个编码单元32位表示的<strong>辅助平面字符</strong></p>
<p>在ES5中，所有字符串的操作都是基于16位编码单元的BMP字符，如果直接用于32位编码单元的辅助平面字符，得到的结果可能与预期不符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>; <span class="comment">//不是‘吉’</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);      <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));  <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>))     <span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>))        <span class="comment">//""</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>))     <span class="comment">//55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>))     <span class="comment">//57271</span></div></pre></td></tr></table></figure></p>
<p><em>𠮷</em>是辅助平面字符，ES5中的字符串操作方法将其视为两个16位字符。</p>
<ul>
<li><code>text</code>的长度是1，但<code>length</code>属性值为2</li>
<li><code>text</code>被判定为两个字符，因此匹配单一字符的正则失效</li>
<li>前后两个16位编码都不表示任何可打印字符，所以<code>charAt()</code>方法不会返回合法的字符串</li>
<li><code>charCodeAt()</code>方法同样不能正确识别字符，他会返回每个16位编码单元对应的数值</li>
</ul>
<h3 id="ES6新增的字符串操作方法"><a href="#ES6新增的字符串操作方法" class="headerlink" title="ES6新增的字符串操作方法"></a>ES6新增的字符串操作方法</h3><p>ES6新增的字符串方法，完全支持UTF-16（辅助平面字符）</p>
<h4 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h4><p>该方法接受<em>编码单元</em>（非字符位置）的位置做为参数，返回字符串中给定位置对应的码位，即一个整数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">//55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">//57271</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">//97</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">//134071</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">//57271</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">//97</span></div></pre></td></tr></table></figure>
<p>对于BMP字符集中的字符，<code>codePointAt</code>和<code>charCodeAt</code>方法返回的值是相同的。<code>text</code>中第一个字符属于辅助平面字符，包含2个编码单元，<code>length</code>值为3。<code>charCodeAt</code>返回的只是位置0处的第一个编码单元，<code>charPointAt</code>返回的是完整的码位，即使这个码位包含2个编码单元。</p>
<p>检测字符占用的编码单元的数量，可以用<code>charPointAt</code>方法，返回值大于十六进制的上界值FFFF，则一定有两个编码单元来表示。（因为不足以表示所有字符，所以才用辅助平面字符来表示）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>)&gt; <span class="number">0xFFFF</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">'𠮷'</span>));  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">'a'</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h4 id="String-fromCodePoint-方法"><a href="#String-fromCodePoint-方法" class="headerlink" title="String.fromCodePoint()方法"></a>String.fromCodePoint()方法</h4><p><code>String.fromCodePoint()</code>接收一个码位，返回一个字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">//𠮷</span></div></pre></td></tr></table></figure></p>
<h4 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h4><p>Unicode中，对不同字符进行排序或比较操作，可能它们是等效的。有两种方式可以定义这种关系</p>
<ul>
<li>规范的等效，两个序列的码位一致</li>
<li>兼容性，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以被互相交换使用。</li>
</ul>
<p>比如Ǒ（\u01D1），O（\u004F）和ˇ（\u030C）组合，可以互相使用，但从严格意义上来讲，它们不是等效。ES6为字符串提供了一个<code>normalize</code>方法，它可以提供Unicode的标准化形式，该方法接收一个可选字符串参数。</p>
<ul>
<li>以标准等价方式分解，然后以标准等价方式重组（’NFC’），默认选项</li>
<li>以标准等价方式分解（NFD）</li>
<li>以兼容等价方式分解（’NFKC’）</li>
<li>以兼容等价方式分解，然后易标准等价方式重组（’NFKD’）<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u01D1'</span> === <span class="string">'\u004F\u030C'</span>);   <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize());   <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>在对比字符串之前，一定要先把它们标准化为同一格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> normalized = values.map(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> text.normalize()</div><div class="line">&#125;)</div><div class="line">normalized.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(a &lt; b)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a === b)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>将<code>values</code>数组中的所有字符都转换成同一种标准格式，因此该数组可以被正确排序</p>
<blockquote>
<p><code>sort</code>方法中的函数，返回值小于0，a在b前面。大于0，a在b后面。等于0，a，b相对位置不变。上面是升序</p>
</blockquote>
<h4 id="字符串中的子串识别"><a href="#字符串中的子串识别" class="headerlink" title="字符串中的子串识别"></a>字符串中的子串识别</h4><ul>
<li><code>includes()</code>，字符串中检测到指定文本返回<code>true</code>，否则<code>false</code></li>
<li><code>startsWith()</code>，字符串起始部分检测到指定文本返回<code>true</code>，否则<code>false</code></li>
<li><code>endsWith()</code>，字符串结束部分检测到指定文本返回<code>true</code>，否则<code>false</code><br>以上方法，都接受两个参数，第一个参数指定要搜索的文本，第二个参数可选，指定开始搜索的位置的索引值。如果指定第二个参数，<code>includes</code>和<code>startWith</code>方法会从这个索引值的位置开始匹配。<code>endsWith</code>方法则从字符串长度减去这个索引值的位置开始匹配。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> msg = <span class="string">'hello world!'</span></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'hello'</span>));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'!'</span>));     <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>));     <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">'o'</span>, <span class="number">4</span>));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">'o'</span>,<span class="number">8</span>))     <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">'o'</span>,<span class="number">8</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>重复字符串方法，接受一个<code>number</code>型参数，表示重复次数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>.repeat(<span class="number">2</span>));     <span class="comment">//'hellohello'</span></div></pre></td></tr></table></figure></p>
<h3 id="正则表达式变更"><a href="#正则表达式变更" class="headerlink" title="正则表达式变更"></a>正则表达式变更</h3><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>正则表达式默认将字符串中的每一个字符按照16位编码单元处理，为了解决这个问题，ES6新增u修饰符。当一个正则表达式添加了u修饰符时，它就从编码单元操作模式切换为字符模式。这样正则表达式就不会把辅助平面字符（代理对）为两个字符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">'𠮷'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);   <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>可以利用u修饰符，检测字符串的码位<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</div><div class="line">    <span class="keyword">return</span> result? result.length: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">'abc'</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">'𠮷bc'</span>));   <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>检测u修饰符支持<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpU</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'.'</span>, <span class="string">'u'</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数使用了RegExp构造函数并传入一个修饰符u作为参数，老式浏览器支持这个语法，如果不支持u修饰符会抛出错误。这样可以避免发生语法错误。</p>
<h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><p>y修饰符的正则表达式称为粘滞正则表达式，他会影响正则表达式搜索过程中的<code>sticky</code>属性，当它在字符串中开始字符匹配时，会通知从正则表达式的<code>lastIndex</code>属性开始进行。如果指定位置未能成功匹配，则停止继续匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">'hello1 hello2 hello3'</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);     <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">//'hello1 '</span></div><div class="line"></div><div class="line">pattern.lastIndex = <span class="number">1</span>;</div><div class="line">globalPattern.lastIndex = <span class="number">1</span>;</div><div class="line">stickyPattern.lastIndex = <span class="number">1</span>;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);     <span class="comment">//'hello1 '</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">//'hello2 '</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">//抛出错误</span></div></pre></td></tr></table></figure></p>
<p>当<code>lastIndex</code>属性改成1时，此时正则表达式从字符串的第二个字符开始匹配。没有修饰符的表达式自动忽略，所以第二个表达式向后匹配到了’hello2 ‘，使用了y修饰符的粘滞正则表达式，由于从第二个字符开始匹配不到相应的字符串，就此终止。所以<code>stickyResult</code>为<code>null</code></p>
<ul>
<li>只有调用<code>exec()</code>和<code>test()</code>这些正则表达式对象的方法时才会涉及<code>lastIndex</code>属性，调用字符串方法如<code>match()</code>不会触发粘滞行为。</li>
<li>对于粘滞正则表达式，如果使用<code>^</code>匹配字符串开端，只会从字符串的起始位置或者多行模式的首行进行匹配。如果此时<code>lastIndex</code>值不为0，则永远不会匹配到结果</li>
</ul>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p>
</blockquote>
<h4 id="正则表达式复制"><a href="#正则表达式复制" class="headerlink" title="正则表达式复制"></a>正则表达式复制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/ab/i</span>,</div><div class="line">    reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg1,<span class="string">'g'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(reg2.toString());   <span class="comment">//  /ab/g</span></div></pre></td></tr></table></figure>
<p>在ES5环境中，<code>RegExp</code>构造函数，第一个参数为正则表达式时不可以使用第二个参数，ES6中修改了这个行为</p>
<h4 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h4><p><code>flags</code>属性用来获取正则表达式的修饰符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/ab/i</span>;</div><div class="line"><span class="built_in">console</span>.log(reg2.flags);    <span class="comment">//i</span></div></pre></td></tr></table></figure></p>
<h3 id="模版字面量"><a href="#模版字面量" class="headerlink" title="模版字面量"></a>模版字面量</h3><p>ES6模版字面量语法支持创建领域专用语言(DSL)，它比ES5及早起版本中的解决方案更家安全。</p>
<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;</div></pre></td></tr></table></figure>
<p>模版字面量用反撇号（`）表示，如果在字符串中使用反撇号，需要用反斜杆（\）进行转义</p>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>在ES5中，可以利用一个语法bug，在一个新行的最前方添加反斜杆（\）可以承接上一行代码，来创造多行字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = <span class="string">'Multiline \</span></div><div class="line"><span class="string">string'</span></div><div class="line"><span class="keyword">var</span> message2 = <span class="string">'Multiline \n\</span></div><div class="line"><span class="string">string'</span></div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">//Multiline string</span></div><div class="line"><span class="built_in">console</span>.log(message2);  <span class="comment">//Multiline </span></div><div class="line">                        <span class="comment">//string</span></div></pre></td></tr></table></figure></p>
<p>反斜杆在此处代表行的延续，而非真正代表新的一行，如果想要输入新的一行，需要手动加入换行符。</p>
<p>ES6之前版本中，通常通过数组活着字符串拼接的方式创建多行字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message1 = [<span class="string">'Multiline'</span>,<span class="string">'string'</span>].join(<span class="string">'\n'</span>);</div><div class="line"><span class="keyword">var</span> message2 = <span class="string">'Multiline \n'</span> + <span class="string">'string'</span></div></pre></td></tr></table></figure></p>
<p>在ES6中的模版字面量，只需在代码中直接换行即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">`Multiline</span></div><div class="line"><span class="string">string`</span></div><div class="line"><span class="built_in">console</span>.log(message);   <span class="comment">//Multiline </span></div><div class="line">                        <span class="comment">//string</span></div></pre></td></tr></table></figure></p>
<p>在反撇号中的所有空白符都输入字符串中的一部分<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">`Multiline</span></div><div class="line"><span class="string">    string`</span>         <span class="comment">//string前面有4个空格</span></div><div class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<p>第二行之前的所有空白符都是字符串本身的一部分</p>
<h4 id="字符串占位符"><a href="#字符串占位符" class="headerlink" title="字符串占位符"></a>字符串占位符</h4><p>占位符由一个美元符和大括号<code>${}</code>组成，中间可以包含任意的<code>JavaScript</code>表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = <span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"><span class="built_in">console</span>.log(message);    <span class="comment">//10 items cost $2.50.</span></div></pre></td></tr></table></figure></p>
<p>第一个美元符会原样输出，因为后面没有紧跟一个左括号</p>
<p>模版字面量本身也是<code>JavaScript</code>表达式，所以可以在一个模版中嵌入另一个<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'Nicholas'</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;</span></span></div><div class="line"><span class="string"><span class="subst">        <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span></span></span></div><div class="line"><span class="string"><span class="subst">    &#125;</span>.`</span>;</div><div class="line"><span class="built_in">console</span>.log(message);   <span class="comment">//Hello, my name is Nicholas.</span></div></pre></td></tr></table></figure></p>
<h3 id="模版标签"><a href="#模版标签" class="headerlink" title="模版标签"></a>模版标签</h3><p>在模版字面量第一个反撇号（`）前方标注的字符串（函数），就是标签。模版标签可以执行模版字面量上的转换，并返回最终的字符串值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = tag<span class="string">`hello world`</span></div></pre></td></tr></table></figure></p>
<p>如示，应用于模版字面量的模版标签是<code>tag</code></p>
<h4 id="定义标签"><a href="#定义标签" class="headerlink" title="定义标签"></a>定义标签</h4><p>标签是一个函数，调用时，第一个参数是一个数组，包含<code>JavaScript</code>解释过后的字面量字符串（模板字符串中那些没有变量替换的部分），之后的所有参数都是每一个占位符的解释值。</p>
<p>标签函数通常使用不定参数特征来定义占位符来简化处理过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = tag<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>)</span>&#123;</div><div class="line">    <span class="comment">// console.log(literals);   [ '', ' items cost $', '.' ]</span></div><div class="line">    <span class="comment">// console.log(substitutions); [ 10, '2.50' ]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例中，<code>tag</code>函数，作为一个模版字面量标签，会接受3个参数。<code>literals</code>是一个数组，包含一下元素</p>
<ul>
<li>第一个占位符前的空字符串（’’）</li>
<li>第一，二个占位符之间的字符串（’ items cost $’）</li>
<li>第二个占位符后的字符串（’.’）</li>
</ul>
<p>第二个参数是变量<code>count</code>的解释值，传参为10，最后一个是<code>count * price).toFixed(2)</code>的解释值，传参为’2.50’</p>
<p><code>literals</code>里第一个元素是空字符串，确保<code>literals[0]</code>是字符串始端，<code>substitutions</code>的数量始终比<code>literals</code>少一个，意味着<code>substitutions.length === literals.length-1</code>表达式始终为<code>true</code></p>
<p>模版标签可以到字符转义被转换成等价字符前的原生字符串，如<code>String.raw()</code>标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message1 = <span class="string">`Multiline\nstring`</span>,</div><div class="line">    message2 = <span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message1);  <span class="comment">//Multiline</span></div><div class="line">                        <span class="comment">//string</span></div><div class="line"><span class="built_in">console</span>.log(message2);  <span class="comment">//'Multiline\\nstring'</span></div></pre></td></tr></table></figure></p>
<p>变量<code>message1</code>中的<code>\n</code>解释为一个新行，变量<code>message2</code>获取的是<code>\n</code>的原生形式<code>\\n</code></p>
<p>原生字符串信息同样也传入标签模版，标签函数第一个参数，它有一个额外的属性<code>raw</code>，是一个包含每一个字面量的原生等价信息的数组。如<code>literals[0]</code>对应的原生字符串为<code>literals.raw[0]</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/16/《深入理解ES6》之块级作用域绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoalYa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoalYa's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/16/《深入理解ES6》之块级作用域绑定/" itemprop="url">《深入理解ES6》之块级作用域绑定</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-16T18:16:01+08:00">
                2017-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/《深入理解ES6》/" itemprop="url" rel="index">
                    <span itemprop="name">《深入理解ES6》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="var声明及变量提升（Hoisting）机制"><a href="#var声明及变量提升（Hoisting）机制" class="headerlink" title="var声明及变量提升（Hoisting）机制"></a>var声明及变量提升（Hoisting）机制</h3><p>在函数作用域或全局作用域钟通过关键字<code>var</code>声明的变量，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升（Hoisting）机制<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        <span class="keyword">var</span> value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//此处可以可访问变量value，其值为undefined</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//此处可以可访问变量value，其值为undefined    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在预编译阶段，JavaScript引擎会将上面的<code>getValue</code>函数修改成下面这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量<code>value</code>的声明提升到函数顶部，初始化操作依然保留在原处执行，这就意味着在<code>else</code>语句中也可以访问到该变量，<br>且由于此时变量尚未初始化，所以其值为<code>undefined</code></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块级声明用于声明在指定块的作用域之外无法访问的变量，块级作用域存在于：</p>
<ul>
<li>函数内部</li>
<li>块中（{}内部）</li>
</ul>
<h4 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h4><p><code>let</code>声明的用法与<code>var</code>相同，用<code>let</code>声明的变量作用域限制在当前代码块中。由于<code>let</code>声明不会被提升，所以通常<br>将<code>let</code>声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(condition)&#123;</div><div class="line">        <span class="keyword">let</span> value = <span class="string">'blue'</span>;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//变量value，此处不存在</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//变量value，此处不存在</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量<code>value</code>该用<code>let</code>声明后，不再提升至函数顶部，<code>if</code>语句执行完后，<code>value</code>立刻被销毁。如果<code>condition</code>为<br><code>false</code>，就永远不会声明并初始化<code>value</code></p>
<h4 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h4><p>如果作用域中已经存在某个标识符，此时再使用<code>let</code>关键字声明它就会抛出错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">//抛出错误</span></div><div class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</div></pre></td></tr></table></figure></p>
<p>变量<code>count</code>被声明了两次，所以在<code>let</code>声明处会抛出错误。但如果当前作用域内嵌另一个作用域，便可以在内嵌作用域<br>中用<code>let</code>声明同名变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"><span class="keyword">if</span>(condition) &#123;</div><div class="line">    <span class="comment">//不会抛出错误</span></div><div class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>关键字<code>const</code>用来声明一个常量，其值一旦设定后就不可更改。所以每个通过<code>const</code>声明的常量必须进行初始化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">//语法错误：常量未初始化</span></div><div class="line"><span class="keyword">const</span> name;</div></pre></td></tr></table></figure></p>
<h4 id="const与let"><a href="#const与let" class="headerlink" title="const与let"></a>const与let</h4><p><code>const</code>与<code>let</code>声明的都是块级标识符，所以也只在当前代码块内有效，也不会被提升至作用域顶部，在同一作用域中<br>也不能重复声明</p>
<h4 id="用const声明对象"><a href="#用const声明对象" class="headerlink" title="用const声明对象"></a>用const声明对象</h4><p><code>const</code>声明的变量不得改变值，对于引用类型数据，变量指向的内存地址，保存的是一个指针。<code>const</code>只能保证这个指针<br>是固定的，指针指向的数据结构是可变的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = &#123;</div><div class="line">    name: <span class="string">'Nico'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//可以修改对象属性的值</span></div><div class="line">Nico.name = <span class="string">'Greg'</span>;</div><div class="line"></div><div class="line"><span class="comment">//抛出语法错误</span></div><div class="line">person = &#123;</div><div class="line">    name: <span class="string">'Greg'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="暂时死区（Temporal-Dead-Zone）"><a href="#暂时死区（Temporal-Dead-Zone）" class="headerlink" title="暂时死区（Temporal Dead Zone）"></a>暂时死区（Temporal Dead Zone）</h4><p><code>let</code>和<code>const</code>声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使相对安全的<code>typeof</code>操作符<br>也会触发引用错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(condition) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">//引用错误</span></div><div class="line">    <span class="keyword">let</span> value = <span class="string">'blue'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>console.log(typeof value)</code>语句会抛出错误，因此用<code>let</code>定义并初始化变量<code>value</code>的语句不会执行，<br>此时<code>value</code>位于临时死区或TDZ中。</p>
<p>JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（<code>var</code>声明），要么将声明放到TDZ中（<code>let</code>和<code>const</code>）。<br>访问TDZ中的变量会出发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。</p>
<h3 id="循环中的块作用域绑定"><a href="#循环中的块作用域绑定" class="headerlink" title="循环中的块作用域绑定"></a>循环中的块作用域绑定</h3><h4 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h4><p><code>var</code>声明在循环中创建函数变得异常困难，因为变量到了循环之外也能访问<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//输出10次数字10</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是因为循环里的每次迭代同时共享着变量<code>i</code>，循环内部创建的函数全都保留了对相同变量的引用。循环结束时变量<br><code>i</code>的值为10，所以每次调用<code>console.log(i)</code>都会输出数字10</p>
<p>为了解决这个问题，可以使用立即调用函数表达式（IIFE），以强制生成计数器变量的副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(value)</div><div class="line">            &#125;</div><div class="line">        &#125;(i)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//0,1,...,9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在循环内部，IIFE表达式为接受的每一个变量<code>i</code>都创建了一个副本并存储为变量<code>value</code>。这个变量的值就是相应迭代创建<br>的函数所使用的值，因此调用每个函数都会像0到9循环一样得到期望的值。</p>
<h4 id="循环中的let声明"><a href="#循环中的let声明" class="headerlink" title="循环中的let声明"></a>循环中的let声明</h4><p>用<code>let</code>来声明上述示例，那么每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func(); <span class="comment">//0,1,...,9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于<code>for-in</code>循环和<code>for-of</code>循环，表现的行为和<code>for</code>循环保持一致。</p>
<h4 id="循环中的const声明"><a href="#循环中的const声明" class="headerlink" title="循环中的const声明"></a>循环中的const声明</h4><p>对于普通的<code>for</code>循环，可以在初始化变量时使用<code>const</code>，但是更改这个变量的值就会抛出错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>for-in</code>或<code>for-of</code>循环中使用<code>const</code>时的行为与使用<code>let</code>一致<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    obj = &#123;</div><div class="line">        a: <span class="literal">true</span>,</div><div class="line">        b: <span class="literal">false</span>,</div><div class="line">        c: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</div><div class="line">    func()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="全局块作用域绑定"><a href="#全局块作用域绑定" class="headerlink" title="全局块作用域绑定"></a>全局块作用域绑定</h3><p><code>let</code>和<code>const</code>与<code>var</code>的另外一个区别是它们在全局作用域的行为。当<code>var</code>被用于全局作用域时，它会创建一个新的全局<br>变量作为全局对象的属性。这意味着可能无意中覆盖了一个已经存在的全局变量。</p>
<p>而在全局作用域使用<code>let</code>或<code>const</code>，不会覆盖全局变量，只能遮蔽它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//浏览器中</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>,<span class="built_in">window</span>.RegExp);  <span class="comment">//'hello' 'hello'</span></div><div class="line"></div><div class="line"><span class="comment">//浏览器中</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">'hello'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>,<span class="built_in">window</span>.RegExp); <span class="comment">// 'hello' function RegExt()&#123; [native code] &#125;</span></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="CoalYa" />
            
              <p class="site-author-name" itemprop="name">CoalYa</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoalYa</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="https://lib.baomitu.com/jquery/2.2.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://lib.baomitu.com/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="https://lib.baomitu.com/velocity/1.2.1/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://lib.baomitu.com/velocity/1.2.1/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="https://lib.baomitu.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
